<!DOCTYPE html><html lang="zh-CN"><head><link href="https://unpkg.com/@splidejs/splide@4.1.4/dist/css/splide.min.css" rel="stylesheet"><style type="text/css">.splide{border:2px solid var(--carousel-border-color);box-shadow:0 4px 8px var(--carousel-shadow-color);border-radius:var(--carousel-border-radius)}.splide__slide img{width:100%;height:100%;object-fit:contain}.carousel-container{visibility:inherit;margin-top:20px;margin-bottom:20px}.carousel-caption{min-height:2em;line-height:2em;text-align:center;font-size:.9em;font-style:italic;padding:6px;margin-left:auto;margin-right:auto}.splide__arrow{background:0 0;align-items:center;border:0;cursor:pointer;display:flex;height:5em;justify-content:center;position:absolute;top:50%;transform:translateY(-50%);width:5em;z-index:10}.splide__arrow:disabled{opacity:0}.splide__arrow--prev{left:0}.splide__arrow--next{right:0}.splide__arrow svg{fill:var(--carousel-arrow-color);height:2.5em;transition:fill .2s linear;width:2.5em}.splide__arrow:hover:not(:disabled) svg{fill:var(--carousel-arrow-hover-color)}.splide__arrow:focus-visible{outline:transparent;outline-offset:0}.splide.is-focus-in .splide__arrow:focus{outline:transparent;outline-offset:0}.splide__pagination__page:focus-visible{outline:transparent;outline-offset:0}.splide.is-focus-in .splide__pagination__page:focus{outline:transparent;outline-offset:0}.splide__pagination{bottom:1em;left:0;padding:0 1em;position:absolute;right:0;z-index:1}.splide__pagination__page{background:var(--carousel-pagination-color);border:0;border-radius:2.5px;display:inline-block;height:5px;margin:3px;width:20px;transition:background-color .2s linear}.splide__pagination__page.is-active{background:var(--carousel-pagination-active-color)}.splide__pagination__page:hover{background:var(--carousel-pagination-hover-color);cursor:pointer;opacity:.9}.splide__pagination__page::before{content:'';position:absolute;top:-18px;bottom:-18px;left:-4px;right:-4px}.splide__pagination__page.is-active::before{content:'';position:absolute;top:-12px;bottom:-12px;left:-1px;right:-1px}.zoomable{object-fit:contain}.zooming{max-width:90vw!important;max-height:90vh!important;object-fit:contain!important}</style><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://unpkg.com" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="manifest" href="/images/site.webmanifest"><meta name="msvalidate.01" content="BE3DB9F22A0915AF3452024048D66934"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CFira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><link rel="stylesheet" href="https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-flash.css"><script src="https://unpkg.com/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"siriusq.top","root":"/","images":"/images","scheme":"Gemini","darkmode":"auto","version":"8.20.0","exturl":false,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":320,"display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":false,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="本文是Bongo Paw Clicker的开发记录，对我在开发鼠标连点器过程中遇到的问题进行了记录"><meta property="og:type" content="article"><meta property="og:title" content="Bongo Paw Clicker 开发记录"><meta property="og:url" content="https://siriusq.top/BongoPawClicker.html"><meta property="og:site_name" content="Sirius"><meta property="og:description" content="本文是Bongo Paw Clicker的开发记录，对我在开发鼠标连点器过程中遇到的问题进行了记录"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.loli.net/2023/08/21/NiZV537WgoJSdX8.webp"><meta property="og:image" content="https://s2.loli.net/2023/08/18/G7k3ueC45sLVzPF.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/GuCkMH4gx7ldKPZ.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/ilZkBTWVf9gUxLO.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/ISOCrNd46uhEwtx.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/HGk9cCoqEwtledn.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/F364xwoDMdYuNEA.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/HVnKk74vDx6oQZW.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/G1knqmbt7juEM2x.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/iVex1vswbLakocI.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/qV8WgfKp1siz3he.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/Ym1iJnjEg9TUR8x.png"><meta property="og:image" content="https://s2.loli.net/2023/08/18/xZBtpjzkPunINsb.png"><meta property="article:published_time" content="2023-08-14T08:02:21.000Z"><meta property="article:modified_time" content="2024-09-12T09:04:24.000Z"><meta property="article:author" content="Sirius"><meta property="article:tag" content="WPF"><meta property="article:tag" content="Bongo Paw Clicker"><meta property="article:tag" content="Log"><meta property="article:tag" content="C#"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2023/08/21/NiZV537WgoJSdX8.webp"><link rel="canonical" href="https://siriusq.top/BongoPawClicker.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://siriusq.top/BongoPawClicker.html","path":"BongoPawClicker.html","title":"Bongo Paw Clicker 开发记录"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Bongo Paw Clicker 开发记录 | Sirius</title><script src="/live2d-widget/autoload.js"></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Sirius" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Sirius</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">May the Force be with you</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">106</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">71</span></a></li><li class="menu-item menu-item-tools"><a href="/tools/" rel="section"><i class="fa fa-screwdriver-wrench fa-fw"></i>Tools</a></li><li class="menu-item menu-item-switch-to-english"><a href="https://siriusq.top/en/" rel="section"><i class="fa fa-language fa-fw"></i>Switch to English</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E9%80%81%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">传送门</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UI%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.</span> <span class="nav-text">UI设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%B8%83%E5%B1%80"><span class="nav-number">2.1.</span> <span class="nav-text">窗口布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Grid"><span class="nav-number">2.1.1.</span> <span class="nav-text">Grid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StackPanel"><span class="nav-number">2.1.2.</span> <span class="nav-text">StackPanel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Material-Design"><span class="nav-number">2.2.</span> <span class="nav-text">Material Design</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E6%A0%B7%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">窗口样式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%8C%89%E9%92%AE"><span class="nav-number">2.3.1.</span> <span class="nav-text">功能按钮</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E9%98%B4%E5%BD%B1"><span class="nav-number">2.3.2.</span> <span class="nav-text">窗口阴影</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%9C%86%E8%A7%92"><span class="nav-number">2.3.3.</span> <span class="nav-text">窗口圆角</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%8A%A8%E7%94%BB"><span class="nav-number">2.3.4.</span> <span class="nav-text">窗口动画</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%A8%E7%94%BB"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">创建动画</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6"><span class="nav-number">2.3.4.1.1.</span> <span class="nav-text">透明度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E6%8B%89%E4%BC%B8"><span class="nav-number">2.3.4.1.2.</span> <span class="nav-text">窗口拉伸</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%8A%A8%E7%94%BB"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">触发动画</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E4%B8%8E%E9%9F%B3%E9%A2%91"><span class="nav-number">3.</span> <span class="nav-text">图像与音频</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87"><span class="nav-number">3.1.</span> <span class="nav-text">应用图标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bongo-Cat"><span class="nav-number">3.2.</span> <span class="nav-text">Bongo Cat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91"><span class="nav-number">3.3.</span> <span class="nav-text">播放音频</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UI%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">UI线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatcher"><span class="nav-number">3.5.</span> <span class="nav-text">Dispatcher</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%9D%A2%E6%9D%BF"><span class="nav-number">4.</span> <span class="nav-text">设置面板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3"><span class="nav-number">4.1.</span> <span class="nav-text">创建窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ShowDialog%E4%B8%8EShow"><span class="nav-number">4.2.</span> <span class="nav-text">ShowDialog与Show</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Show"><span class="nav-number">4.2.1.</span> <span class="nav-text">Show</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ShowDialog"><span class="nav-number">4.2.2.</span> <span class="nav-text">ShowDialog</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2"><span class="nav-number">5.</span> <span class="nav-text">主题切换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E7%82%B9%E5%87%BB"><span class="nav-number">6.</span> <span class="nav-text">模拟点击</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SetCursorPos"><span class="nav-number">6.1.</span> <span class="nav-text">SetCursorPos</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mouse-event"><span class="nav-number">6.2.</span> <span class="nav-text">mouse_event</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E9%BC%A0%E6%A0%87%E5%9D%90%E6%A0%87"><span class="nav-number">7.</span> <span class="nav-text">捕获鼠标坐标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3-1"><span class="nav-number">7.1.</span> <span class="nav-text">创建窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%85%89%E6%A0%87%E5%9D%90%E6%A0%87"><span class="nav-number">7.2.</span> <span class="nav-text">获取光标坐标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%86%E9%80%89%E8%8C%83%E5%9B%B4%E9%A2%84%E8%A7%88%E4%B8%8E%E6%8D%95%E8%8E%B7"><span class="nav-number">7.3.</span> <span class="nav-text">框选范围预览与捕获</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE"><span class="nav-number">8.</span> <span class="nav-text">存储用户配置</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%83%AD%E9%94%AE%E8%AE%BE%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">热键设置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%95%E5%85%A5%E7%83%AD%E9%94%AE"><span class="nav-number">9.1.</span> <span class="nav-text">录入热键</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UI"><span class="nav-number">9.1.1.</span> <span class="nav-text">UI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">9.1.2.</span> <span class="nav-text">键盘事件预处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C-%E6%B3%A8%E9%94%80%E5%85%A8%E5%B1%80%E7%83%AD%E9%94%AE"><span class="nav-number">9.2.</span> <span class="nav-text">注册&#x2F;注销全局热键</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RegisterHotKey-%E5%87%BD%E6%95%B0"><span class="nav-number">9.2.1.</span> <span class="nav-text">RegisterHotKey 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UnregisterHotKey-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">9.2.2.</span> <span class="nav-text">UnregisterHotKey 函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E7%83%AD%E9%94%AE%E5%8A%9F%E8%83%BD"><span class="nav-number">9.2.3.</span> <span class="nav-text">绑定热键功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%83%AD%E9%94%AE%E6%B6%88%E6%81%AF"><span class="nav-number">9.2.4.</span> <span class="nav-text">处理热键消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E7%83%AD%E9%94%AE"><span class="nav-number">9.3.</span> <span class="nav-text">更改热键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E5%92%8C%E4%BF%9D%E5%AD%98%E7%83%AD%E9%94%AE"><span class="nav-number">9.4.</span> <span class="nav-text">读取和保存热键</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">本地化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-number">10.1.</span> <span class="nav-text">创建资源文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">10.2.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XAML"><span class="nav-number">10.2.1.</span> <span class="nav-text">XAML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Code"><span class="nav-number">10.2.2.</span> <span class="nav-text">Code</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C"><span class="nav-number">10.3.</span> <span class="nav-text">运行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F"><span class="nav-number">11.</span> <span class="nav-text">打包程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Costura-Fody"><span class="nav-number">11.1.</span> <span class="nav-text">Costura.Fody</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">11.1.1.</span> <span class="nav-text">安装与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">11.1.2.</span> <span class="nav-text">新的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%B1%9E%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="nav-number">11.1.3.</span> <span class="nav-text">附属程序集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E9%9B%86%EF%BC%88Primary-Assembly%EF%BC%89"><span class="nav-number">11.1.3.1.</span> <span class="nav-text">主程序集（Primary Assembly）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%99%84%E5%B1%9E%E7%A8%8B%E5%BA%8F%E9%9B%86%EF%BC%88Satellite-Assembly%EF%BC%89"><span class="nav-number">11.1.3.2.</span> <span class="nav-text">附属程序集（Satellite Assembly）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">11.1.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">11.1.4.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resource-Embedder"><span class="nav-number">11.2.</span> <span class="nav-text">Resource.Embedder</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Net-Framework"><span class="nav-number">12.</span> <span class="nav-text">.Net Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NET-Framework-%E7%89%88%E6%9C%AC%E4%B8%8E-Windows-%E7%89%88%E6%9C%AC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">12.1.</span> <span class="nav-text">.NET Framework 版本与 Windows 版本的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Net-Core-%E4%B8%8E-Net-Framework"><span class="nav-number">12.2.</span> <span class="nav-text">.Net Core 与 .Net Framework</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Sirius" src="https://s2.loli.net/2022/05/23/kxtRKT4u71HXlUY.gif"><p class="site-author-name" itemprop="name">Sirius</p><div class="site-description" itemprop="description">一只差点变成建筑狗的程序猿</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">106</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/Siriusq" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Siriusq" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS Feed → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS Feed</a> </span><span class="links-of-author-item"><a href="mailto:siriusq.top@outlook.com" title="E-Mail → mailto:siriusq.top@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://leetcode.com/Siriusq/" title="LeetCode → https:&#x2F;&#x2F;leetcode.com&#x2F;Siriusq&#x2F;" rel="noopener me" target="_blank"><i class="fa fa-code fa-fw"></i>LeetCode</a></span></div><script src="/js/switch_limited.js"></script></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://siriusq.top/BongoPawClicker.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://s2.loli.net/2022/05/23/kxtRKT4u71HXlUY.gif"><meta itemprop="name" content="Sirius"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Sirius"><meta itemprop="description" content="一只差点变成建筑狗的程序猿"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Bongo Paw Clicker 开发记录 | Sirius"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Bongo Paw Clicker 开发记录</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-08-14 16:02:21" itemprop="dateCreated datePublished" datetime="2023-08-14T16:02:21+08:00">2023-08-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-09-12 17:04:24" itemprop="dateModified" datetime="2024-09-12T17:04:24+08:00">2024-09-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">个人项目</span></a> </span></span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>46 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote class="blockquote-center">本文是Bongo Paw Clicker的开发记录，对我在开发鼠标连点器过程中遇到的问题进行了记录</blockquote><p><img data-src="https://s2.loli.net/2023/08/21/NiZV537WgoJSdX8.webp" alt="cn-preview.webp"></p><span id="more"></span><h1 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h1><div class="link-grid"><div class="link-grid-container"><object class="link-grid-image" data="/images/link/bongoClicker.webp"></object><p>Bongo Paw Clicker</p><p>一个集成了邦鼓猫 (Bongo Cat) 的自动鼠标连点器</p><a target="_blank" rel="noopener" href="https://github.com/Siriusq/BongoPawClicker/releases/download/v1.0/BongoPawClicker.exe"></a></div><div class="link-grid-container"><object class="link-grid-image" data="/images/link/github.webp"></object><p>Github Repo Link</p><p>Bongo Paw Clicker 的 GitHub 仓库链接</p><a target="_blank" rel="noopener" href="https://github.com/Siriusq/BongoPawClicker"></a></div></div><h1 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h1><p>WPF使用可扩展应用程序标记语言 (<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/visualstudio/xaml-tools/xaml-overview?view=vs-2022">XAML</a>)来生成UI，VS中的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/visualstudio/xaml-tools/creating-a-ui-by-using-xaml-designer-in-visual-studio?view=vs-2022">XAML设计器</a>提供了一个可视界面来帮助我们进行UI设计。XAML在使用上和CSS比较像，上手基本没有难度，难的是设计。吐槽：程序员自己做UI设计是真的心累，我设计UI的时间比写代码的时间都长。</p><h2 id="窗口布局"><a href="#窗口布局" class="headerlink" title="窗口布局"></a>窗口布局</h2><p>我在UI中使用了Grid和StackPanel进行UI布局，Grid用于划分横向功能区，StackPanel用于在Grid的每行中横向排布组件。更多布局方式见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/visualstudio/xaml-tools/organize-objects-into-layout-containers-in-xaml-designer?view=vs-2022">微软文档</a></p><p>如果直接在同一个Grid中加入多个组件的话，这些组件会堆叠到一起，而不是按照顺序排列。如果要让组件均匀排列，需要为每个组件指定Margin，很麻烦，所以我才在Grid中嵌套了StackPanel来排布组件。</p><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>顾名思义，Grid就是将面板划分为不同的网格</p><details class="note success"><summary><p>Grid示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.RowDefinitions</span>&gt;</span> <span class="comment">&lt;!--定义行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">&quot;50&quot;</span> /&gt;</span> <span class="comment">&lt;!--定义首行参数，此处设置首行行高为50--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">&quot;60&quot;</span> /&gt;</span> <span class="comment">&lt;!--第二行参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.RowDefinitions</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid</span> <span class="attr">Grid.Row</span>=<span class="string">&quot;0&quot;</span>&gt;</span> <span class="comment">&lt;!--第一行--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Grid.ColumnDefinitions</span>&gt;</span> <span class="comment">&lt;!--定义列--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;130&quot;</span> /&gt;</span> <span class="comment">&lt;!--定义首列参数，此处设置首列列宽为130--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;*&quot;</span> /&gt;</span> <span class="comment">&lt;!--第二列参数，此处*代表将列宽设为此行剩余的所有宽度，如果有多个列的宽度设置为*，则代表这些列均分剩余宽度--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Grid</span> <span class="attr">Grid.Column</span>=<span class="string">&quot;0&quot;</span>&gt;</span> <span class="comment">&lt;!--第一列的内容--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Some Content --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">Grid</span> <span class="attr">Grid.Column</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="comment">&lt;!--第二列的内容--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Some Content --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid</span> <span class="attr">Grid.Row</span>=<span class="string">&quot;1&quot;</span>&gt;</span> <span class="comment">&lt;!--第二行--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;2*&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 这里2*标识占据所有宽度的七分之二--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ColumnDefinition</span> <span class="attr">Width</span>=<span class="string">&quot;5*&quot;</span> /&gt;</span> <span class="comment">&lt;!-- 这里2*标识占据所有宽度的七分之五--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Grid.ColumnDefinitions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure></details><h3 id="StackPanel"><a href="#StackPanel" class="headerlink" title="StackPanel"></a>StackPanel</h3><p>StackPanel可以实现在单个行中水平或者垂直排列组件，它不会自动换行，超出宽度的内容会不可视。</p><details class="note success"><summary><p>StackPanel示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">StackPanel</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Height</span>=<span class="string">&quot;60&quot;</span> &lt;!<span class="attr">--设置高度--</span>&gt;</span></span><br><span class="line">    HorizontalAlignment=&quot;Left&quot; <span class="comment">&lt;!--设置水平对齐方式--&gt;</span></span><br><span class="line">    VerticalAlignment=&quot;Center&quot; <span class="comment">&lt;!--设置垂直对齐方式--&gt;</span></span><br><span class="line">    Orientation=&quot;Horizontal&quot;&gt; <span class="comment">&lt;!--设置排列方向--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Label</span> <span class="attr">VerticalAlignment</span>=<span class="string">&quot;Center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AccessText</span> <span class="attr">Text</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Label</span> <span class="attr">VerticalAlignment</span>=<span class="string">&quot;Center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">AccessText</span> <span class="attr">Text</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br></pre></td></tr></table></figure></details><h2 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h2><p>起初我是想自己写一个UI样式，写着写着就发现自己很天真，圆角的半径、按钮的动画什么的真的让我很头大。于是决定摆烂，直接在程序中套用UI框架，这样做的好处是省事且美观，缺点是程序打包后的文件体积会变大。挑选了半天，我最后选择了<a target="_blank" rel="noopener" href="https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit">Material Design In XAML</a></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在<code>App.xaml</code>中添加一个新的命名空间引用：<code>xmlns:materialDesign=&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;</code>，然后再添加几个<code>ResourceDictionary</code>。</p><details class="note success"><summary><p>App.xaml</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x:Class</span>=<span class="string">&quot;[PackageName].App&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:x</span>=<span class="string">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:local</span>=<span class="string">&quot;clr-namespace:[PackageName]&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:materialDesign</span>=<span class="string">&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">StartupUri</span>=<span class="string">&quot;MainWindow.xaml&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">&quot;pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">&quot;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ResourceDictionary</span> <span class="attr">Source</span>=<span class="string">&quot;pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ResourceDictionary.MergedDictionaries</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Application</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>然后在每个窗口对应的xaml文件的Window Tag中添加命名空间引用和相关属性(可选)。</p><details class="note success"><summary><p>Window Tag</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">已经存在的内容</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:materialDesign</span>=<span class="string">&quot;http://materialdesigninxaml.net/winfx/xaml/themes&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">TextElement.Foreground</span>=<span class="string">&quot;&#123;DynamicResource MaterialDesignBody&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Background</span>=<span class="string">&quot;&#123;DynamicResource MaterialDesignPaper&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">TextElement.FontWeight</span>=<span class="string">&quot;Medium&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">TextElement.FontSize</span>=<span class="string">&quot;14&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">FontFamily</span>=<span class="string">&quot;&#123;materialDesign:MaterialDesignFont&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">其他内容</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window</span>&gt;</span></span><br></pre></td></tr></table></figure></details><h2 id="窗口样式"><a href="#窗口样式" class="headerlink" title="窗口样式"></a>窗口样式</h2><p>因为我想实现无边框的窗口（又菜又爱玩），就在Window Tag中将<code>WindowStyle</code>设置成<code>None</code>了。这么做的好处是很自由，能够随心所欲的设计窗口样式，缺点就是太自由了，关闭、最小化等功能按钮都需要自己重新实现，Windows原生的动画效果也全部没有了。</p><h3 id="功能按钮"><a href="#功能按钮" class="headerlink" title="功能按钮"></a>功能按钮</h3><p>首先在<code>MainWindow.xaml</code>文件中重绘顶栏，左侧是应用标题，右侧是功能按钮，功能按钮共有三个，分别为设置、最小化以及关闭应用。然后在按钮中绑定<code>Click</code>事件。</p><details class="note success"><summary><p>关闭按钮示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--MainWindow.xaml 关闭按钮示例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x:Name</span>=<span class="string">&quot;CloseButton&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Width</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Height</span>=<span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Margin</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">VerticalAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Click</span>=<span class="string">&quot;CloseButton_Click&quot;</span> //<span class="attr">绑定关闭事件</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Style</span>=<span class="string">&quot;&#123;StaticResource MaterialDesignFloatingActionMiniButton&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">WindowChrome.IsHitTestVisibleInChrome</span>=<span class="string">&quot;True&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">materialDesign:PackIcon</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Width</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Height</span>=<span class="string">&quot;25&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Kind</span>=<span class="string">&quot;Close&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>最后在<code>MainWindow.xaml.cs</code>中重新实现按钮的功能。</p><ul><li>关闭窗口：<code>Close()</code>；</li><li>最小化：<code>this.WindowState = WindowState.Minimized</code>；</li><li>拖拽窗口：<code>DragMove()</code>;</li></ul><details class="note success"><summary><p>关闭窗口示例</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainWindow.xaml.cs 关闭窗口示例</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CloseButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Close(); <span class="comment">//关闭窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="窗口阴影"><a href="#窗口阴影" class="headerlink" title="窗口阴影"></a>窗口阴影</h3><p>实现阴影效果需要允许窗口透明，并将窗口背景设置为空值</p><details class="note success"><summary><p>MainWindow.xaml相关Tag示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">其他内容</span></span></span><br><span class="line"><span class="tag">    <span class="attr">AllowsTransparency</span>=<span class="string">&quot;True&quot;</span> //<span class="attr">允许透明</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Background</span>=<span class="string">&quot;&#123;x:Null&#125;&quot;</span> //<span class="attr">背景设置为空值</span></span></span><br><span class="line"><span class="tag">    <span class="attr">WindowStyle</span>=<span class="string">&quot;None&quot;</span> //<span class="attr">不使用Windows默认窗口样式</span></span></span><br><span class="line"><span class="tag">    //<span class="attr">其他内容</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>下面是两个错误示例，左边的图片没有设置允许窗口透明，窗口的边框会显示黑色。右边的图片将背景设置为了红色。</p><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/G7k3ueC45sLVzPF.png" alt="bpc_shadow2.png"></div><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/GuCkMH4gx7ldKPZ.png" alt="bpc_shadow1.png"></div></div></div><p>阴影效果我使用了Grid中的<code>DropShadowEffect</code>实现。</p><details class="note success"><summary><p>DropShadowEffect示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Grid.Effect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DropShadowEffect</span></span></span><br><span class="line"><span class="tag">        <span class="attr">BlurRadius</span>=<span class="string">&quot;15&quot;</span> //<span class="attr">表示阴影模糊效果半径的值</span>，<span class="attr">默认值为5</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Opacity</span>=<span class="string">&quot;0.8&quot;</span> //<span class="attr">数值越大阴影越明显</span></span></span><br><span class="line"><span class="tag">        <span class="attr">ShadowDepth</span>=<span class="string">&quot;0&quot;</span> //<span class="attr">设置阴影与窗口的距离</span>，<span class="attr">阴影会随着数值增大向窗口右下方移动</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Color</span>=<span class="string">&quot;#666666&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid.Effect</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>此时是看不到窗口的阴影的，因为阴影是环绕在Grid的外围的，而当前的Grid已经占用了全部的窗口空间，阴影自然就不可见了。所以需要通过<code>Margin</code>属性为Grid设置外边距，Margin具体的数值要根据阴影的宽度设置。</p><h3 id="窗口圆角"><a href="#窗口圆角" class="headerlink" title="窗口圆角"></a>窗口圆角</h3><p>圆角效果有多种实现方式，可以使用Card中的<code>UniformCornerRadius=&quot;半径&quot;</code>统一设置4个圆角的半径，也可以使用Border中的<code>CornerRadius=&quot;左上半径,右上半径,右下半径,左下半径&quot;</code>分别设置每个圆角的半径。我使用了Card，并将圆角半径设置为15。</p><details class="note success"><summary><p>窗口圆角示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">materialDesign:Card</span> <span class="attr">Background</span>=<span class="string">&quot;&#123;DynamicResource CardBackgroundColor&#125;&quot;</span> <span class="attr">UniformCornerRadius</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></details><h3 id="窗口动画"><a href="#窗口动画" class="headerlink" title="窗口动画"></a>窗口动画</h3><p>需要重新实现的动画有窗口启动、窗口关闭、最小化、从最小化恢复窗口四个。</p><ul><li>窗口启动：模仿Windows原生动画</li><li>窗口关闭：模仿Windows原生动画</li><li>最小化：窗口向下滑动，同时透明度逐渐降低</li><li>恢复窗口：窗口从底部滑动出现，同时透明度逐渐增加</li></ul><h4 id="创建动画"><a href="#创建动画" class="headerlink" title="创建动画"></a>创建动画</h4><p>Windows原生启动动画的效果是窗口透明度逐渐增加，窗口从0.7-0.8倍尺寸向四周逐渐扩大至正常尺寸，窗口关闭动画则相反，我这里以加载窗口的动画为例。为实现近似的效果，需要创建一个<code>Storyboard</code>，并向其中添加三个<code>DoubleAnimation</code>，分别是透明度变化、横向拉伸和竖向拉伸。</p><h5 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h5><p>透明度变化的动画很简单，下面的代码实现的是窗口启动时透明度由0到1的变化。注意其中的<code>FillBehavior</code>属性，它的默认值是<code>HoldEnd</code>，意味着动画中To的值会覆写程序原本的值，这在某些情况下会造成问题，解决方法是将它设置为<code>Stop</code>。</p><details class="note success"><summary><p>透明度动画</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DoubleAnimation</span></span></span><br><span class="line"><span class="tag">    <span class="attr">FillBehavior</span>=<span class="string">&quot;Stop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Storyboard.TargetProperty</span>=<span class="string">&quot;Opacity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">From</span>=<span class="string">&quot;0&quot;</span> //<span class="attr">初始透明度</span></span></span><br><span class="line"><span class="tag">    <span class="attr">To</span>=<span class="string">&quot;1&quot;</span> //<span class="attr">最终透明度</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Duration</span>=<span class="string">&quot;0:0:0.2&quot;</span> //<span class="attr">动画播放时间0.2秒</span> /&gt;</span></span><br></pre></td></tr></table></figure></details><h5 id="窗口拉伸"><a href="#窗口拉伸" class="headerlink" title="窗口拉伸"></a>窗口拉伸</h5><p>首先在主Grid中设置<code>x:Name</code>和<code>RenderTransformOrigin</code>属性。<code>x:Name</code>用于拉伸动画寻找对应的Grid，<code>RenderTransformOrigin</code>用于设置动画的起点，取值范围是0-1，设置为<code>0,0</code>时动画的起点是窗口的左上角，设置为<code>1,1</code>时动画的起点是窗口的右下角。我这里设置为<code>0.5,0.5</code>，即窗口的中心。</p><p>然后向Grid中添加<code>RenderTransform</code>属性，<code>RenderTransform</code>是一个用于控制元素呈现时的变换的属性。它允许你对元素应用平移、缩放、旋转和倾斜等变换效果，以改变元素的呈现位置、大小和方向。这里我为了方便后续添加其他效果使用了<code>TransformGroup</code>类，它是 WPF 中的一个用于组合多个变换效果的容器类，它允许你将多个平移、缩放、旋转、倾斜等变换组合在一起，从而可以同时应用这些变换效果到一个元素上。</p><p>下一步是在上面创建的<code>Storyboard</code>中添加横向拉伸和竖向拉伸的动画DoubleAnimation<code>，使用</code>Storyboard.TargetName<code>指定拉伸对象，使用</code>Storyboard.TargetProperty&#96;指定变形类型。</p><details class="note success"><summary><p>窗口拉伸动画</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window.Resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载窗口动画的Storyboard--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Storyboard</span> <span class="attr">x:Key</span>=<span class="string">&quot;ShowWindow&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--透明度动画--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DoubleAnimation</span></span></span><br><span class="line"><span class="tag">                <span class="attr">FillBehavior</span>=<span class="string">&quot;Stop&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Storyboard.TargetProperty</span>=<span class="string">&quot;Opacity&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">From</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">To</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Duration</span>=<span class="string">&quot;0:0:0.2&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--横向拉伸--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DoubleAnimation</span></span></span><br><span class="line"><span class="tag">                <span class="attr">FillBehavior</span>=<span class="string">&quot;Stop&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Storyboard.TargetName</span>=<span class="string">&quot;MainGrid&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Storyboard.TargetProperty</span>=<span class="string">&quot;(UIElement.RenderTransform).(TransformGroup.Children)[0].(ScaleX)&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">From</span>=<span class="string">&quot;0.8&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">To</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Duration</span>=<span class="string">&quot;0:0:0.2&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--纵向拉伸--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DoubleAnimation</span></span></span><br><span class="line"><span class="tag">                <span class="attr">FillBehavior</span>=<span class="string">&quot;Stop&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Storyboard.TargetName</span>=<span class="string">&quot;MainGrid&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Storyboard.TargetProperty</span>=<span class="string">&quot;(UIElement.RenderTransform).(TransformGroup.Children)[0].(ScaleY)&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">From</span>=<span class="string">&quot;0.8&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">To</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">Duration</span>=<span class="string">&quot;0:0:0.2&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Storyboard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window.Resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--目标网格--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Grid</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x:Name</span>=<span class="string">&quot;MainGrid&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Margin</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">RenderTransformOrigin</span>=<span class="string">&quot;0.5,0.5&quot;</span>&gt;</span> <span class="comment">&lt;!--动画的起点--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid.RenderTransform</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">TransformGroup</span>&gt;</span> <span class="comment">&lt;!--容器类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ScaleTransform</span> <span class="attr">ScaleX</span>=<span class="string">&quot;1&quot;</span> <span class="attr">ScaleY</span>=<span class="string">&quot;1&quot;</span> /&gt;</span> <span class="comment">&lt;!--缩放--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SkewTransform</span> /&gt;</span> <span class="comment">&lt;!--扭曲--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RotateTransform</span> /&gt;</span> <span class="comment">&lt;!--旋转--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TranslateTransform</span> /&gt;</span> <span class="comment">&lt;!--平移--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">TransformGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid.RenderTransform</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--其他内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br></pre></td></tr></table></figure></details><h4 id="触发动画"><a href="#触发动画" class="headerlink" title="触发动画"></a>触发动画</h4><p>窗口加载动画的触发很简单，在xaml文件中添加一个<code>Window.Triggers</code>即可。</p><details class="note success"><summary><p>Window.Triggers示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window.Triggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">EventTrigger</span> <span class="attr">RoutedEvent</span>=<span class="string">&quot;Loaded&quot;</span>&gt;</span> <span class="comment">&lt;!--窗口加载时触发--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">BeginStoryboard</span> <span class="attr">Storyboard</span>=<span class="string">&quot;&#123;StaticResource ShowWindow&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">EventTrigger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Window.Triggers</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>但是最小化窗口等动画不太适合直接使用<code>Window.Triggers</code>，因为有一些特殊情况需要判定是否播放动画，所以我还是在代码中触发这些动画。下面是用于触发窗口从最小化恢复的动画的代码，需要先在xaml文件的Window Tag中添加一行<code>StateChanged=&quot;Window_StateChanged&quot;</code>来绑定窗口状态改变事件。</p><details class="note success"><summary><p>窗口状态改变代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Window_StateChanged</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当窗口透明度为0且尺寸恢复正常时，执行从最小化恢复的动画</span></span><br><span class="line">    <span class="comment">//因为我的最小化动画最终会将窗口的透明度设置为0，也方便了这里进行判定</span></span><br><span class="line">    <span class="comment">//如果不判定窗口的透明度，窗口在失去焦点但并没有最小化的情况下重新获得焦点时，动画也会被触发</span></span><br><span class="line">    <span class="keyword">if</span> (WindowState == WindowState.Normal &amp;&amp; <span class="keyword">this</span>.Opacity==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> story = (Storyboard)<span class="keyword">this</span>.Resources[<span class="string">&quot;MaximizeWindow&quot;</span>];</span><br><span class="line">        story.Begin(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="图像与音频"><a href="#图像与音频" class="headerlink" title="图像与音频"></a>图像与音频</h1><p>我在根目录下新建了一个Asset文件夹来存放图像、音频等媒体资源。</p><h2 id="应用图标"><a href="#应用图标" class="headerlink" title="应用图标"></a>应用图标</h2><p>我的图标设计的很简单粗暴，一只Bongo Cat抱着一个鼠标光标，PS里几步操作就完成了。添加图标的步骤为打开项目<code>属性</code>，在<code>应用程序</code>菜单的<code>资源</code>选项中点选<code>图标和清单</code>，然后单击<code>浏览</code>按钮并找到自己的图标即可。图标文件仅支持<code>ico</code>格式<br><img data-src="https://s2.loli.net/2023/08/18/ilZkBTWVf9gUxLO.png" alt="bpc_icon.png"></p><h2 id="Bongo-Cat"><a href="#Bongo-Cat" class="headerlink" title="Bongo Cat"></a>Bongo Cat</h2><p>我通过切换4张不同状态下的Bongo Cat的图片来实现Bongo Cat的爪子随着鼠标点击同步拍桌子的效果。</p><ul><li>默认状态：两只猫爪都是抬起来的</li><li>鼠标左键单击：左侧猫爪拍下</li><li>鼠标左键双击：两只猫爪同时拍下</li><li>鼠标右键单击：右侧猫爪拍下</li></ul><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/ISOCrNd46uhEwtx.png" alt="nonePaw.png"></div><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/HGk9cCoqEwtledn.png" alt="leftPaw.png"></div><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/F364xwoDMdYuNEA.png" alt="rightPaw.png"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/HVnKk74vDx6oQZW.png" alt="bothPaw.png"></div></div></div><p>首先提前在PS中处理四张图片，对齐Bongo Cat的身体轮廓，导出为相同大小的文件。然后放置在同一个Canvas下并设置相同的尺寸与对齐方式，除默认状态下的图片，其他三张图片的<code>Visibility</code>属性都设置为<code>&quot;Collapsed&quot;</code>。</p><details class="note primary"><summary><p>Visibility属性</p></summary><blockquote><p>以下内容由ChatGPT生成</p></blockquote><p><code>Visibility</code> 属性用于控制一个元素在界面上的可见性。在 WPF 中，<code>Visibility</code> 属性有三个可能的值：<code>Visible</code>、<code>Collapsed</code> 和 <code>Hidden</code>。</p><ol><li><strong>Visible</strong>：元素是可见的，并且占据布局空间。它会显示在界面上，并响应用户交互。</li><li><strong>Collapsed</strong>：元素是不可见的，并且不占据布局空间。它不会显示在界面上，也不会占用任何空间。与 <code>Visible</code> 不同，使用 <code>Collapsed</code> 后该元素不会留下空白，周围的布局会紧凑起来。</li><li><strong>Hidden</strong>：元素是不可见的，但它仍然占据布局空间。与 <code>Visible</code> 相似，只是元素不会显示出来，但它会占用空间，导致周围的布局不会紧凑。</li></ol><p>一般来说，如果你想要完全隐藏一个元素，并且希望周围的布局重新排列以填补它的位置，你可以使用 <code>Collapsed</code>。如果你希望元素不显示，但仍然占用空间，你可以使用 <code>Hidden</code>。。</p></details><p>然后在代码中进行处理，以左键单击为例，当模拟鼠标左键单击事件时，将左边爪子拍下的图片设置为可见，并折叠默认状态下的图片，等待100毫秒后恢复原样。</p><details class="note success"><summary><p>左键单击示例</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clickType == <span class="number">0</span>)<span class="comment">//左键单击</span></span><br><span class="line">&#123;</span><br><span class="line">    Dispatcher.InvokeAsync((Action)(<span class="keyword">async</span> () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        LeftPaw.Visibility = Visibility.Visible;</span><br><span class="line">        NonePaw.Visibility = Visibility.Collapsed;</span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">100</span>);</span><br><span class="line">        LeftPaw.Visibility = Visibility.Collapsed;</span><br><span class="line">        NonePaw.Visibility = Visibility.Visible;</span><br><span class="line">    &#125;));</span><br><span class="line">    User32API.ClickOnScreen(<span class="number">0</span>, xCoord, yCoord);<span class="comment">//模拟点击</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>用户中断点击事件的执行时，图片的切换也会被中断，当前显示的图片可能不是默认状态下的图片，所以在模拟点击命令中断或结束后还需要将图片恢复默认状态。</p><h2 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h2><p>我在添加音频时遇到了一个很奇怪的问题，如果直接在xaml中使用MediaPlayer，就必须在代码中使用绝对路径调用音频文件，使用相对路径就会提示找不到资源，最后我是把音频文件加入到了<code>Resources.resx</code>中，然后通过<code>Properties.Resources.[FileName]</code>调用成功的。</p><details class="note success"><summary><p>播放音频代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//音频播放器</span></span><br><span class="line">    System.Media.SoundPlayer meowAudio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//窗口加载时载入音频</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Window_Loaded</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        meowAudio = <span class="keyword">new</span> System.Media.SoundPlayer(Properties.Resources.meow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行模拟点击完成后播放音频</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ClickLuncher</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dispatcher.InvokeAsync((Action)(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            meowAudio.Play();</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这里还有一个比较坑的地方，<code>Resources.resx</code>中默认显示的资源类型是字符串，需要通过左上角的下拉菜单切换到音频，而且只有点击到一个非常小非常不明显的小箭头才能打开下拉菜单，如下图所示。</p><p><img data-src="https://s2.loli.net/2023/08/18/G1knqmbt7juEM2x.png" alt="bpc_audio.png"></p><details class="note primary"><summary><p>UI线程与Dispatcher</p></summary><blockquote><p>部分内容来自ChatGPT</p></blockquote><p>你可能已经注意到了，在代码中切换猫爪图片需要使用到<code>Dispatcher</code>，因为这里涉及到了UI线程的问题。</p><h2 id="UI线程"><a href="#UI线程" class="headerlink" title="UI线程"></a>UI线程</h2><p>UI线程是负责处理用户界面交互和更新的线程。在WPF应用程序中，UI线程负责处理用户界面元素（如窗口、按钮、文本框等）的创建、显示、交互和更新操作。UI线程负责绘制界面、响应用户输入以及处理各种UI事件。</p><p>UI线程的重要性在于它的线程上下文。大多数UI框架，包括WPF，要求所有与UI相关的操作都在同一个线程上进行，以确保线程安全。这就意味着你不能在非UI线程上直接更新UI元素，否则可能会引发跨线程问题。</p><p>UI线程通常有以下特点：</p><ul><li>单线程模型： 在大多数UI框架中，包括WPF，UI线程是单线程模型。这意味着所有UI元素的创建、修改和交互都必须在同一个UI线程上进行。</li><li>用户界面操作： UI线程负责处理用户界面的各种操作，包括响应用户输入、处理鼠标和键盘事件、处理窗口状态变化（最大化、最小化等）等。</li><li>渲染绘制： UI线程负责渲染和绘制用户界面元素，确保它们正确地显示在屏幕上。</li><li>响应性： 为了保持应用程序的响应性，UI线程应该保持轻量级，以便能够及时响应用户的操作。</li><li>线程安全： UI线程的操作必须是线程安全的，以避免并发和同步问题。</li></ul><p>当进行长时间运算或涉及耗时操作时，应该将这些操作分离到非UI线程，以保持用户界面的流畅性。但在更新UI元素时，你仍然需要使用<code>Dispatcher</code>将操作发送到UI线程，以确保线程安全。</p><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p><code>Dispatcher</code> 是WPF中的一个机制，允许你在非UI线程上将操作调度到UI线程上执行。通过使用<code>Dispatcher</code>，你可以确保UI元素的更新和操作都发生在正确的线程上，避免了线程安全问题。</p><p>例如，如果你在一个后台线程上计算某些值，并希望将计算结果显示在UI界面上，你需要通过<code>Dispatcher</code>将更新操作发送到UI线程。这样做可以保证UI元素的更新不会导致跨线程问题。</p><p><code>Dispatcher</code>中含有三个常用方法，即<code>Invoke</code>，<code>BeginInvoke</code>和<code>InvokeAsync</code>。</p><ul><li><code>Invoke</code>是同步方法，意味着调用线程将会被阻塞，直到操作在UI线程上完成为止。</li><li><code>BeginInvoke</code>和<code>InvokeAsync</code>都是异步方法，它会将操作加入到UI线程的消息队列中，然后立即返回，不会阻塞调用线程，可以继续执行后续代码。InvokeAsync是在<code>.NET Framework 4.5</code>中新引入的，两者的主要区别是对异常的处理方式，建议首选InvokeAsync，特别是需要使用<code>await</code>方法的时候。</li></ul></details><h1 id="设置面板"><a href="#设置面板" class="headerlink" title="设置面板"></a>设置面板</h1><p>我在程序中单独创建了设置面板的窗口，设置面板的功能有：</p><ul><li>切换程序的明&#x2F;暗主题</li><li>设置程序是否始终置顶</li><li>设置热键</li><li>设置点击完成后的提醒</li></ul><h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><p>首先在主窗口的xaml文件中添加一个按钮并绑定点击事件<code>Click=&quot;SettingButton_Click&quot;</code>，然后在项目中添加一个新的窗口并命名为<code>SettingPanel</code>。随后打开主窗口的代码文件，找到并编辑自动生成的方法代码。<br><img data-src="https://s2.loli.net/2023/08/18/iVex1vswbLakocI.png" alt="bpc_sp1.png"></p><details class="note success"><summary><p>创建设置窗口</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SettingButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SettingPanel settingPanel = <span class="keyword">new</span> SettingPanel(); <span class="comment">//创建设置窗口</span></span><br><span class="line">    settingPanel.WindowStartupLocation = WindowStartupLocation.CenterOwner;<span class="comment">//设置窗口启动时的位置，这里设置为在主窗口的中心</span></span><br><span class="line">    settingPanel.Owner = <span class="keyword">this</span>; <span class="comment">//将主窗口设为设置窗口的拥有者</span></span><br><span class="line">    settingPanel.ShowDialog(); <span class="comment">//显示设置窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details class="note primary"><summary><p>ShowDialog与Show</p></summary><blockquote><p>以下内容来自ChatGPT</p></blockquote><h2 id="ShowDialog与Show"><a href="#ShowDialog与Show" class="headerlink" title="ShowDialog与Show"></a>ShowDialog与Show</h2><p>在WPF中，Show和ShowDialog是两种不同的方式来显示窗口</p><h3 id="Show"><a href="#Show" class="headerlink" title="Show"></a>Show</h3><ul><li>使用Show方法显示的窗口是非模态的，即它不会阻止用户与应用程序的其他部分进行交互。</li><li>用户可以在打开的窗口之间自由切换，甚至可以在主窗口和其他打开的窗口之间进行交互。</li><li>Show方法会立即返回，而不会等待打开的窗口关闭。</li></ul><h3 id="ShowDialog"><a href="#ShowDialog" class="headerlink" title="ShowDialog"></a>ShowDialog</h3><ul><li>使用ShowDialog方法显示的窗口是模态的，即它会阻止用户与应用程序的其他部分进行交互，直到该窗口被关闭。</li><li>用户必须先关闭模态窗口，才能回到主窗口或其他已打开的窗口。</li><li>ShowDialog方法会在打开的窗口关闭后才返回，因此它可以用于实现需要用户响应的对话框。</li></ul></details><h1 id="主题切换"><a href="#主题切换" class="headerlink" title="主题切换"></a>主题切换</h1><p>在深夜测试的时候感觉默认的亮色主题有些刺眼，于是决定增加一个暗色的主题，并在设置窗口中添加一个按钮用于主题的切换。</p><p><code>Material Design</code>已经内置了亮色和暗色主题，也内置了几套<code>Primary Color</code>配色方案，而<code>Primary Color</code>又分为Light、Normal和Dark三种颜色，TextBox、ToggleButton等组件使用的是Light配色，Button使用的是Dark配色。我对它的Light配色不太满意，就通过资源字典增加了一套配色，在程序的背景、Toggle按钮等组件上使用自己的颜色方案，在普通按钮上沿用<code>Material Design</code>的配色。</p><p>首先在<code>App.xaml</code>中添加两个<code>SolidColorBrush</code>属性，其中<code>CardBackgroundColor</code>是窗口的背景颜色，<code>IndicatorColor</code>是各个控件的主题颜色，这里默认是亮色主题。</p><details class="note success"><summary><p>SolidColorBrush示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Application.Resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SolidColorBrush</span> <span class="attr">x:Key</span>=<span class="string">&quot;CardBackgroundColor&quot;</span>&gt;</span>#f8f8ff<span class="tag">&lt;/<span class="name">SolidColorBrush</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">SolidColorBrush</span> <span class="attr">x:Key</span>=<span class="string">&quot;IndicatorColor&quot;</span>&gt;</span>#b39ddb<span class="tag">&lt;/<span class="name">SolidColorBrush</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--其他资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ResourceDictionary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Application.Resources</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>然后在<code>SettingPanel.xaml</code>中添加一个开关按钮，使用<code>Checked</code>和<code>Unchecked</code>绑定打开和关闭开关的两个事件。</p><details class="note success"><summary><p>开关按钮示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ToggleButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x:Name</span>=<span class="string">&quot;DarkModeToggleButton&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Margin</span>=<span class="string">&quot;10,0,0,0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Background</span>=<span class="string">&quot;&#123;DynamicResource IndicatorColor&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Checked</span>=<span class="string">&quot;DarkModeToggleButton_Checked&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Effect</span>=<span class="string">&quot;&#123;StaticResource MaterialDesignElevationShadow2&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Style</span>=<span class="string">&quot;&#123;StaticResource MaterialDesignSwitchLightToggleButton&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Unchecked</span>=<span class="string">&quot;DarkModeToggleButton_Unchecked&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></details><p>然后编辑<code>SettingPanel.xaml.cs</code>中对应的方法。起初我把切换主题的所有代码都放在了设置窗口中，但是我在点击开关时发现，只有设置窗口自己的主题颜色改变了，主窗口只是切换成了Material Design的内置暗色主题，我自定义的颜色并没有改变，后来发现需要在主窗口中强制刷新<code>Dynamic Resources</code>才能更改自定义的颜色，索性直接把切换主题的代码放到了主窗口里。</p><details class="note success"><summary><p>设置窗口的代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SettingPanel.xaml.cs</span></span><br><span class="line"><span class="comment">//仅强制当前窗口刷新Dynamic Resources</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切换暗色主题</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DarkModeToggleButton_Checked</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Owner <span class="keyword">is</span> MainWindow mainWindow)</span><br><span class="line">    &#123;</span><br><span class="line">        mainWindow.SwitchToDarkMode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//强制当前窗口刷新Dynamic Resources</span></span><br><span class="line">    Resources[<span class="string">&quot;CardBackgroundColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#3d3d3d&quot;</span>));</span><br><span class="line">    Resources[<span class="string">&quot;IndicatorColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#ffb330&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切换亮色主题</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DarkModeToggleButton_Unchecked</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Owner <span class="keyword">is</span> MainWindow mainWindow)</span><br><span class="line">    &#123;</span><br><span class="line">        mainWindow.SwitchToLightMode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//强制当前窗口刷新Dynamic Resources</span></span><br><span class="line">    Resources[<span class="string">&quot;CardBackgroundColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#f8f8ff&quot;</span>));</span><br><span class="line">    Resources[<span class="string">&quot;IndicatorColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#b39ddb&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details class="note success"><summary><p>主窗口中的代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainWindow.xaml.cs</span></span><br><span class="line"><span class="comment">//切换主题的主要代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切换至深色模式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchToDarkMode</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> paletteHelper = <span class="keyword">new</span> PaletteHelper();</span><br><span class="line">    <span class="comment">//获取主题自带配色琥珀色</span></span><br><span class="line">    PrimaryColor primary = PrimaryColor.Amber;</span><br><span class="line">    Color primaryColor = SwatchHelper.Lookup[(MaterialDesignColor)primary];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换自定义配色，背景颜色为深灰色，组件颜色为金黄色</span></span><br><span class="line">    Resources[<span class="string">&quot;CardBackgroundColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#3d3d3d&quot;</span>));</span><br><span class="line">    Resources[<span class="string">&quot;IndicatorColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#ffb330&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换至Material Design自带的深色主题</span></span><br><span class="line">    ITheme theme = paletteHelper.GetTheme();</span><br><span class="line">    theme.SetBaseTheme(Theme.Dark);</span><br><span class="line">    theme.SetPrimaryColor(primaryColor);</span><br><span class="line">    paletteHelper.SetTheme(theme);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchToLightMode</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> paletteHelper = <span class="keyword">new</span> PaletteHelper();</span><br><span class="line">    <span class="comment">//获取主题自带配色深紫色</span></span><br><span class="line">    PrimaryColor primary = PrimaryColor.DeepPurple;</span><br><span class="line">    Color primaryColor = SwatchHelper.Lookup[(MaterialDesignColor)primary];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换自定义配色，背景颜色为烟灰色，组件颜色为淡紫色</span></span><br><span class="line">    Resources[<span class="string">&quot;CardBackgroundColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#f8f8ff&quot;</span>));</span><br><span class="line">    Resources[<span class="string">&quot;IndicatorColor&quot;</span>] = <span class="keyword">new</span> SolidColorBrush((Color)ColorConverter.ConvertFromString(<span class="string">&quot;#b39ddb&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换至Material Design自带的亮色主题</span></span><br><span class="line">    ITheme theme = paletteHelper.GetTheme();</span><br><span class="line">    theme.SetBaseTheme(Theme.Light);</span><br><span class="line">    theme.SetPrimaryColor(primaryColor);</span><br><span class="line">    paletteHelper.SetTheme(theme);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>最后给需要应用自定义配色的组件设置<code>Background=&quot;&#123;DynamicResource IndicatorColor&#125;&quot;</code>或者<code>BorderBrush=&quot;&#123;DynamicResource IndicatorColor&#125;&quot;</code>属性，不再使用Material Design的<code>Primary Color</code>。</p><h1 id="模拟点击"><a href="#模拟点击" class="headerlink" title="模拟点击"></a>模拟点击</h1><p>模拟鼠标点击需要调用<code>user32.dll</code>，<code>user32.dll</code>是 Windows 操作系统的一个核心 DLL，包含了很多用户界面相关的函数，如创建窗口、显示消息框、处理输入等等。user32.dll需要通过<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/standard/native-interop/pinvoke">P&#x2F;Invoke（Platform Invocation Services）</a>在.NET程序中进行调用，代码为<code>[DllImport(&quot;user32.dll&quot;)]</code>，相应托管方法的声明中需要添加<code>extern</code>关键字来说明这是一个外部方法。</p><p>我新建了一个名为User32API.cs的类来存放与<code>user32.dll</code>相关的代码。具体的点击分为两步，第一步是通过<code>SetCursorPos</code>函数将光标移动到用户设定的屏幕坐标点，第二步是通过<code>mouse_event</code>函数根据用户输入的点击类型进行点击。</p><h2 id="SetCursorPos"><a href="#SetCursorPos" class="headerlink" title="SetCursorPos"></a>SetCursorPos</h2><p>SetCursorPos 函数用于将鼠标光标移动到指定的屏幕坐标位置。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetCursorPos</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>X：目标屏幕像素坐标的 X 值，即水平位置。</li><li>Y：目标屏幕像素坐标的 Y 值，即垂直位置。</li></ul><p>该函数调用后会将鼠标光标移动到指定的坐标位置，无论此时鼠标是否在活动窗口内。另外这个函数不会显示移动的过程。</p><p>如果提供的 X 或 Y 值超出了屏幕的边界，系统会将鼠标位置限制在屏幕的可见区域内。例如，如果你将 X 设置为一个负数，系统会将其限制在左边界上，而如果你将 X 设置为一个大于屏幕宽度的值，系统会将其限制在右边界上。同样的逻辑也适用于 Y 值。</p><details class="note success"><summary><p>SetCursorPos引用示例</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">SetCursorPos</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure></details><h2 id="mouse-event"><a href="#mouse-event" class="headerlink" title="mouse_event"></a>mouse_event</h2><p>mouse_event 函数用于模拟鼠标操作，如鼠标的点击、移动、滚动等。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">mouse_event</span><span class="params">(</span></span><br><span class="line"><span class="params">  DWORD     dwFlags,</span></span><br><span class="line"><span class="params">  DWORD     dx,</span></span><br><span class="line"><span class="params">  DWORD     dy,</span></span><br><span class="line"><span class="params">  DWORD     dwData,</span></span><br><span class="line"><span class="params">  ULONG_PTR dwExtraInfo</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>dwFlags是表示鼠标操作的标志位，指定了<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-mouse_event">操作类型</a>（如点击、移动、滚动等）<ul><li><details class="note success"><summary><p>常用操作类型</p></summary><table><thead><tr><th align="left">类型</th><th align="left">数值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">MOUSEEVENTF_ABSOLUTE</td><td align="left">0x8000</td><td align="left">绝对坐标标志</td></tr><tr><td align="left">MOUSEEVENTF_LEFTDOWN</td><td align="left">0x0002</td><td align="left">按下左键</td></tr><tr><td align="left">MOUSEEVENTF_LEFTUP</td><td align="left">0x0004</td><td align="left">抬起左键</td></tr><tr><td align="left">MOUSEEVENTF_RIGHTDOWN</td><td align="left">0x0008</td><td align="left">按下右键</td></tr><tr><td align="left">MOUSEEVENTF_RIGHTUP</td><td align="left">0x0010</td><td align="left">抬起右键</td></tr></tbody></table></details></li></ul></li><li>dx和dy有两种用法<ul><li>如果使用 <code>MOUSEEVENTF_ABSOLUTE</code> 标志，那么 <code>dx</code> 和 <code>dy</code> 就被解释为绝对的屏幕坐标。这时候，它们的取值范围通常是从 0 到 65535。这是因为屏幕坐标系统通常是一个0到65535的范围，其中 (0, 0) 表示屏幕的左上角，(65535, 65535) 表示屏幕的右下角。如果你想要模拟鼠标在屏幕上的绝对移动，需要使用绝对坐标值。<ul><li><details class="note success"><summary><p>示例：将鼠标移动到屏幕中心</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> screenWidth = <span class="number">1920</span>;</span><br><span class="line"><span class="built_in">int</span> screenHeight = <span class="number">1080</span>;</span><br><span class="line"><span class="built_in">int</span> centerX = (screenWidth * <span class="number">65535</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> centerY = (screenHeight * <span class="number">65535</span>) / <span class="number">2</span>;</span><br><span class="line">mouse_event(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE, centerX, centerY, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></details></li></ul></li><li>如果不使用 <code>MOUSEEVENTF_ABSOLUTE</code> 标志，<code>dx</code> 和 <code>dy</code> 就被解释为相对移动的像素数。这时候，它们的取值范围通常是一个有符号的16位整数，负值表示向左或向上移动，正值表示向右或向下移动。</li></ul></li><li>dwData用于标识滚轮滚动距离，大于零表示向上移动，小于零表示向下移动。如果dwFlags中不包含鼠标滚动事件，则设置为0</li><li>dwExtraInfo表示额外的信息，通常设置为0</li></ul><details class="note success"><summary><p>模拟点击示例</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> MOUSEEVENT_LEFTDOWN = <span class="number">0x0002</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> MOUSEEVENTF_LEFTUP = <span class="number">0x0004</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> MOUSEEVENTF_RIGHTDOWN = <span class="number">0x0008</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> MOUSEEVENTF_RIGHTUP = <span class="number">0x0010</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> MOUSEEVENTF_ABSOLUTE = <span class="number">0x8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右键单击</span></span><br><span class="line">mouse_event(MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_RIGHTUP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左键单击</span></span><br><span class="line">mouse_event(MOUSEEVENT_LEFTDOWN | MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//左键双击（也就是两次左键单击）</span></span><br><span class="line">mouse_event(MOUSEEVENT_LEFTDOWN | MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mouse_event(MOUSEEVENT_LEFTDOWN | MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></details><h1 id="捕获鼠标坐标"><a href="#捕获鼠标坐标" class="headerlink" title="捕获鼠标坐标"></a>捕获鼠标坐标</h1><p>让用户直接输入要点击的坐标并不现实，因为屏幕上并没有像素标尺告诉用户光标目前在哪里，所以需要设计一个能够实时显示光标坐标，并且在用户按下鼠标左键后捕获当前光标像素坐标的窗口。另外因为我在程序中增加了区域内随机点击的支持，所以这个窗口也需要支持通过框选获像素坐标。</p><h2 id="创建窗口-1"><a href="#创建窗口-1" class="headerlink" title="创建窗口"></a>创建窗口</h2><ol><li>首先新建一个窗口</li><li>将窗口状态设置为最大化并置顶窗口，且不使用默认的窗口样式</li><li>允许窗口透明并将透明度设置为0.5，用户可以透过半透明的窗口看到原本显示的内容。</li><li>绑定键盘输入事件<code>KeyDown</code>，实现当用户按下<code>Esc</code>键时关闭窗口的功能</li><li>绑定鼠标移动事件<code>MouseMove</code>，实现实时更新光标的像素坐标</li><li>绑定鼠标左键的按下和抬起事件，实现点选获取坐标，框选获取坐标范围</li><li>添加两个Label，随鼠标移动更新像素坐标</li><li>添加一个Rectangle，用于框选范围预览</li></ol><details class="note success"><summary><p>捕获鼠标坐标窗口Window Tag示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Window</span></span></span><br><span class="line"><span class="tag">    <span class="attr">AllowsTransparency</span>=<span class="string">&quot;True&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Background</span>=<span class="string">&quot;Gray&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">KeyDown</span>=<span class="string">&quot;PositionSelector_KeyDown&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">MouseLeftButtonDown</span>=<span class="string">&quot;PositionSelectorCanvas_MouseLeftButtonDown&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">MouseLeftButtonUp</span>=<span class="string">&quot;PositionSelectorCanvas_MouseLeftButtonUp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">MouseMove</span>=<span class="string">&quot;PositionSelectorCanvas_MouseMove&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Opacity</span>=<span class="string">&quot;0.5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">Topmost</span>=<span class="string">&quot;True&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">WindowState</span>=<span class="string">&quot;Maximized&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">WindowStyle</span>=<span class="string">&quot;None&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></details><h2 id="获取光标坐标"><a href="#获取光标坐标" class="headerlink" title="获取光标坐标"></a>获取光标坐标</h2><p>我们可以使用<code>e.GetPosition(this)</code>来获取坐标，<code>GetPosition</code>是在 WPF 中用于获取鼠标或者触摸操作相对于一个指定元素的本地坐标的方法。它返回的是<code>Point</code>对象，<code>Point</code> 是一个表示二维坐标点的结构。它具有两个属性：<code>X</code> 和 <code>Y</code>，分别表示点的水平和垂直坐标，<code>Point.X</code>与<code>Point.Y</code>都是<code>double</code>类型。</p><p>注意这里获取到的是窗口内地本地坐标，并不是屏幕的绝对像素坐标，需要通过<code>PointToScreen</code>方法将它转化为屏幕坐标。<code>PointToScreen</code>方法接受一个 <code>Point</code> 对象，这个 <code>Point</code> 对象代表了相对于调用这个方法的元素的坐标。方法会返回一个 <code>Point</code> 对象，表示该坐标在屏幕上的绝对位置。</p><h2 id="框选范围预览与捕获"><a href="#框选范围预览与捕获" class="headerlink" title="框选范围预览与捕获"></a>框选范围预览与捕获</h2><p>预览框需要随着光标的移动而实时变化，每次触发鼠标移动事件<code>MouseMove</code>时都要重新设定矩形的长宽。由于预览框是在窗口内绘制的，所以这里直接使用窗口本地坐标。另外还需要考虑到用户反向框选的可能性，即从右下角向左上角框选，所以矩形的长度和宽度需要取两个点位坐标差的绝对值。</p><p>如果用户开启了在随机范围内点击，那么程序需要捕获两个屏幕坐标：框选的起始点与结束点，也就是鼠标左键按下和抬起的点位。我使用了变量w表示矩形的宽度，变量h表示矩形的高度，w与h的值就是两个点位的水平和垂直坐标的差的绝对值。</p><details class="note success"><summary><p>框选相关代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//屏幕像素坐标</span></span><br><span class="line"><span class="keyword">private</span> Point mouseDownPoint;</span><br><span class="line"><span class="keyword">private</span> Point mouseUpPoint;</span><br><span class="line"><span class="keyword">private</span> Point currentPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> randomAreaSelection = <span class="literal">false</span>;<span class="comment">//开启随机点击</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isDragging = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//框选范围参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> w = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地窗口坐标</span></span><br><span class="line"><span class="keyword">private</span> Point previewRectangleStartPoint;</span><br><span class="line"><span class="keyword">private</span> Point previewRectangleEndPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标左键按下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PositionSelectorCanvas_MouseLeftButtonDown</span>(<span class="params"><span class="built_in">object</span> sender, MouseButtonEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//框选的起始点</span></span><br><span class="line">    mouseDownPoint = PointToScreen(e.GetPosition(<span class="keyword">this</span>));</span><br><span class="line">    x = (<span class="built_in">int</span>)mouseDownPoint.X;</span><br><span class="line">    y = (<span class="built_in">int</span>)mouseDownPoint.Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果开启范围内随机点击</span></span><br><span class="line">    <span class="keyword">if</span> (randomAreaSelection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//预览框的起始点</span></span><br><span class="line">        previewRectangleStartPoint = e.GetPosition(<span class="keyword">this</span>);</span><br><span class="line">        isDragging = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//显示预览框</span></span><br><span class="line">        SelectedAreaPreview.Visibility = Visibility.Visible;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标左键抬起</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PositionSelectorCanvas_MouseLeftButtonUp</span>(<span class="params"><span class="built_in">object</span> sender, MouseButtonEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果开启范围内随机点击</span></span><br><span class="line">    <span class="keyword">if</span> (randomAreaSelection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//框选的结束点</span></span><br><span class="line">        mouseUpPoint = PointToScreen(e.GetPosition(<span class="keyword">this</span>));</span><br><span class="line">        w = (<span class="built_in">int</span>)mouseUpPoint.X - x;</span><br><span class="line">        h = (<span class="built_in">int</span>)mouseUpPoint.Y - y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果用户反向框选，则转化相关参数</span></span><br><span class="line">        <span class="keyword">if</span> (w &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x += w;</span><br><span class="line">            w *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            y += h;</span><br><span class="line">            h *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        isDragging = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//隐藏预览框</span></span><br><span class="line">        SelectedAreaPreview.Visibility = Visibility.Hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标移动</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PositionSelectorCanvas_MouseMove</span>(<span class="params"><span class="built_in">object</span> sender, MouseEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取光标的实时屏幕坐标并更新Label中的内容</span></span><br><span class="line">    currentPoint = PointToScreen(e.GetPosition(<span class="keyword">this</span>));</span><br><span class="line">    XCoordsPreview.Content = (<span class="built_in">int</span>)currentPoint.X;</span><br><span class="line">    YCoordsPreview.Content = (<span class="built_in">int</span>)currentPoint.Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预览框拖拽点</span></span><br><span class="line">    previewRectangleEndPoint = e.GetPosition(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (randomAreaSelection &amp;&amp; isDragging)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//更新代表预览框的矩形</span></span><br><span class="line">        SelectedAreaPreview.Margin = <span class="keyword">new</span> Thickness(</span><br><span class="line">            Math.Min((<span class="built_in">int</span>)previewRectangleStartPoint.X, (<span class="built_in">int</span>)previewRectangleEndPoint.X),</span><br><span class="line">            Math.Min((<span class="built_in">int</span>)previewRectangleStartPoint.Y, (<span class="built_in">int</span>)previewRectangleEndPoint.Y),</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        SelectedAreaPreview.Width = Math.Abs((<span class="built_in">int</span>)previewRectangleEndPoint.X - (<span class="built_in">int</span>)previewRectangleStartPoint.X);</span><br><span class="line">        SelectedAreaPreview.Height = Math.Abs((<span class="built_in">int</span>)previewRectangleEndPoint.Y - (<span class="built_in">int</span>)previewRectangleStartPoint.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="存储用户配置"><a href="#存储用户配置" class="headerlink" title="存储用户配置"></a>存储用户配置</h1><p>存储用户的自定义配置，当程序启动时自动加载并恢复用户配置，当程序关闭时刷新并保存用户配置。</p><p>首先打开<code>./Properties/Settings.settings</code>，添加需要保存的属性，设置它们的初始值与类型。然后在主窗口的<code>Window Tag</code>中绑定窗口加载事件<code>Loaded=&quot;Window_Loaded&quot;</code>。最后在代码中使用<code>Properties.Settings.Default.[属性名称]</code>来读取相关属性。</p><p>在窗口关闭事件<code>Close()</code>前使用<code>Properties.Settings.Default.Save();</code>来保存相关属性。</p><h1 id="热键设置"><a href="#热键设置" class="headerlink" title="热键设置"></a>热键设置</h1><p>如果用户将点击的间隔设置的比较小，将无法通过点击停止按钮来提前结束模拟点击，因为程序会一直将光标移动到预设的点位，所以必须实现使用热键来停止点击的功能。另外由于本程序的热键可能与用户使用的其他程序的热键产生冲突，所以需要实现允许用户自定义热键的功能。</p><h2 id="录入热键"><a href="#录入热键" class="headerlink" title="录入热键"></a>录入热键</h2><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>我在设置窗口中添加了一个文本框来记录用户按下的键位，然后添加了一个完成按钮来触发后续操作。</p><p>文本框需要设置为只读，并绑定<code>PreviewKeyDown</code>事件。与普通的<code>KeyDown</code>事件不同，<code>PreviewKeyDown</code>事件是一个隧道事件，它从父元素沿着视觉树向下传递，然后再从目标元素冒泡回来。这个事件的作用是允许在按下键之后，但还没有释放键之前，对键盘事件进行预处理或拦截。</p><details class="note success"><summary><p>文本框示例</p></summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">x:Name</span>=<span class="string">&quot;HotKeyTextBox&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">VerticalContentAlignment</span>=<span class="string">&quot;Center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">IsReadOnly</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">PreviewKeyDown</span>=<span class="string">&quot;HotKeyTextBox_PreviewKeyDown&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">TextWrapping</span>=<span class="string">&quot;NoWrap&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">VerticalScrollBarVisibility</span>=<span class="string">&quot;Hidden&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></details><h3 id="键盘事件预处理"><a href="#键盘事件预处理" class="headerlink" title="键盘事件预处理"></a>键盘事件预处理</h3><p>当<code>PreviewKeyDown</code>事件被触发后，程序会判断用户按下的键位是否合法，因为有一些特殊的键位不能用作热键，需要排除掉它们。处理完成后再将用户按下的键位以字符串的形式返回到文本框中。</p><p>用户按下的键位分为两类，一类是Key，另一类是ModifierKeys，它们都是用于处理键盘输入的枚举类型。</p><ul><li>Key：Key定义了所有可能的键盘按键，包括字母、数字、功能键、控制键等。通过这个枚举可以判断用户按下了哪个键。以下是一些 Key 枚举的示例：<ul><li>Key.A: 表示字母 A 键</li><li>Key.Escape: 表示 Esc 键</li><li>Key.Enter: 表示 Enter 键</li><li>Key.Space: 表示空格键</li><li>完整的枚举详见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.input.key?view=windowsdesktop-7.0">微软官方文档</a></li></ul></li><li>ModifierKeys：ModifierKeys定义了一组修饰键，这些键通常与其他键一起使用，以执行某些特定操作。这些修饰键包括 Shift、Ctrl、Alt 和 Windows 键。以下是 ModifierKeys 枚举的一些示例：<ul><li>ModifierKeys.None: 无修饰键被按下</li><li>ModifierKeys.Shift: Shift 键被按下</li><li>ModifierKeys.Control: Ctrl 键被按下</li><li>ModifierKeys.Alt: Alt 键被按下</li></ul></li></ul><p>由于Key枚举中部分键位与ModifierKeys中的修饰键是同一个键位，所以要将这些键位排除掉。</p><details class="note success"><summary><p>键盘事件预处理代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Key hotKey;</span><br><span class="line"><span class="keyword">private</span> ModifierKeys hotKeyModifiers;</span><br><span class="line"></span><br><span class="line"><span class="comment">//键盘预处理事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HotKeyTextBox_PreviewKeyDown</span>(<span class="params"><span class="built_in">object</span> sender, KeyEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断Key是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (IsForbiddenKey(e.Key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果按键非法则阻止按键事件继续传播</span></span><br><span class="line">            e.Handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将用户输入的键位赋值到变量中</span></span><br><span class="line">        hotKey = e.Key;</span><br><span class="line">        hotKeyModifiers = Keyboard.Modifiers;</span><br><span class="line">        UpdateHotKeyText();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        MessageBox.Show(ex.ToString(), <span class="string">&quot;Error!&quot;</span>, MessageBoxButton.OK, MessageBoxImage.Error);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新文本框</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateHotKeyText</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    HotKeyTextBox.Text = <span class="string">$&quot;<span class="subst">&#123;hotKeyModifiers&#125;</span> + <span class="subst">&#123;hotKey&#125;</span>&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">bool</span> <span class="title">IsForbiddenKey</span>(<span class="params">Key key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Enum.IsDefined(<span class="keyword">typeof</span>(ForbiddenKeys), key.ToString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非法Key枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ForbiddenKeys</span><br><span class="line">&#123;</span><br><span class="line">    Back,</span><br><span class="line">    Capital, CapsLock,</span><br><span class="line">    Delete, Down,</span><br><span class="line">    End, Enter, Escape,</span><br><span class="line">    Home,</span><br><span class="line">    Insert,</span><br><span class="line">    Left, LeftAlt, LeftCtrl, LeftShift, LWin,</span><br><span class="line">    Next, NumLock,</span><br><span class="line">    PageDown, PageUp, Pause, PrintScreen,</span><br><span class="line">    Return, Right, RightAlt, RightCtrl, RightShift, RWin,</span><br><span class="line">    System,</span><br><span class="line">    Tab,</span><br><span class="line">    Up,</span><br><span class="line">    VolumeDown, VolumeMute, VolumeUp</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h2 id="注册-注销全局热键"><a href="#注册-注销全局热键" class="headerlink" title="注册&#x2F;注销全局热键"></a>注册&#x2F;注销全局热键</h2><p>全局热键的注册与注销也会使用到<code>user32.dll</code>，注册使用的函数是<code>RegisterHotKey</code>。注销使用的函数是<code>UnregisterHotKey</code>。建议在程序启动时注册全局热键，并在退出时注销，以免与其他程序的热键产生冲突。</p><h3 id="RegisterHotKey-函数"><a href="#RegisterHotKey-函数" class="headerlink" title="RegisterHotKey 函数"></a>RegisterHotKey 函数</h3><p>用途：在操作系统中注册一个全局热键，该热键可以由用户定义，并且在应用程序处于后台运行或没有焦点时也可以触发。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">return: MarshalAs(UnmanagedType.Bool)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">RegisterHotKey</span>(<span class="params">IntPtr hWnd, <span class="built_in">int</span> id, ModifierKeys fsModifiers, <span class="built_in">uint</span> vk</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hWnd: 要接收热键通知的窗口的句柄,通常是主窗口的句柄。</li><li>id: 热键的标识符。用于标识不同的热键。</li><li>fsModifiers: 热键修饰符，如 Ctrl、Alt、Shift 等。</li><li>vk: 要与热键一起使用的虚拟键码，可通过Key转化。</li></ul><p>默认情况下，如果成功注册热键，则返回非零值；如果失败，则返回零。但是为了后续处理方便，这里使用了<code>MarshalAs</code>将返回值转换为布尔类型。</p><h3 id="UnregisterHotKey-函数："><a href="#UnregisterHotKey-函数：" class="headerlink" title="UnregisterHotKey 函数："></a>UnregisterHotKey 函数：</h3><p>用途：取消先前注册的全局热键。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DllImport(<span class="string">&quot;user32.dll&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">bool</span> <span class="title">UnregisterHotKey</span>(<span class="params">IntPtr hWnd, <span class="built_in">int</span> id</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>hWnd: 先前注册热键时提供的窗口句柄。</li><li>id: 先前注册热键时提供的热键标识符。</li></ul><h3 id="绑定热键功能"><a href="#绑定热键功能" class="headerlink" title="绑定热键功能"></a>绑定热键功能</h3><p>在<code>User32API.cs</code>创建一个新的方法<code>Regist</code>用来绑定热键的功能。当程序启动时，主窗口会从用户配置中读取并传入Key与ModifierKeys，然后通过回调函数传入需要绑定热键的命令。</p><details class="note success"><summary><p>主窗口代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写窗口初始化函数</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnSourceInitialized</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnSourceInitialized(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向User32API.cs中的Regist方法传递相关参数</span></span><br><span class="line">    Regist(<span class="keyword">this</span>, hotKeyModifiers, hotKey, () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (StopButton.IsEnabled) &#123; StopButton.RaiseEvent(<span class="keyword">new</span> RoutedEventArgs(System.Windows.Controls.Primitives.ButtonBase.ClickEvent)); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; StartButton.RaiseEvent(<span class="keyword">new</span> RoutedEventArgs(System.Windows.Controls.Primitives.ButtonBase.ClickEvent)); &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>此外我还在这里定义了一个委托类型<code>HotKeyCallBackHanlder</code>，它是一个指向函数的指针，用于定义在全局热键被触发时要执行的操作。</p><p>委托 <code>delegate</code> 是存有对某个方法的引用的一种引用类型变量，它允许我们定义方法的签名，然后可以将这个签名用作方法参数，或者将其赋值给其他方法变量，以便在运行时动态调用方法。</p><details class="note success"><summary><p>注册热键代码及说明</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">HotKeyCallBackHanlder</span>()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HotKeyCallBackHanlder hotKeyCallBackHanlder = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Regist</span>(<span class="params">Window window, ModifierKeys fsModifiers, Key key, HotKeyCallBackHanlder callBack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取窗口的句柄</span></span><br><span class="line">    <span class="keyword">var</span> hwnd = <span class="keyword">new</span> WindowInteropHelper(window).Handle;</span><br><span class="line">    <span class="comment">//使用窗口句柄创建一个 HwndSource 对象</span></span><br><span class="line">    <span class="keyword">var</span> _hwndSource = HwndSource.FromHwnd(hwnd);</span><br><span class="line">    <span class="comment">//将消息处理委托 WndProc 添加到窗口的消息处理链中，窗口收到消息后会先传递给 WndProc 方法进行处理</span></span><br><span class="line">    _hwndSource.AddHook(WndProc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将传入的Key转化为虚拟键码vk</span></span><br><span class="line">    <span class="keyword">var</span> vk = KeyInterop.VirtualKeyFromKey(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果注册失败则弹窗报错</span></span><br><span class="line">    <span class="keyword">if</span> (!RegisterHotKey(hwnd, HOTKEY_ID, fsModifiers, (<span class="built_in">uint</span>)vk))</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Failed to register global hotkey!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将回调函数赋值给了 hotKeyCallBackHanlder 变量。这个回调函数就是在注册时由主窗口传入的 callBack 参数</span></span><br><span class="line">    hotKeyCallBackHanlder = callBack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="处理热键消息"><a href="#处理热键消息" class="headerlink" title="处理热键消息"></a>处理热键消息</h3><p>在 Windows 中，<code>WndProc</code> 是用于处理窗口消息的函数。当注册的热键被触发时，系统会发送一个窗口消息给指定的窗口句柄，然后我们就可以在 WndProc 函数中处理这个消息。</p><details class="note success"><summary><p>处理窗口消息 WndProc</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IntPtr <span class="title">WndProc</span>(<span class="params">IntPtr hwnd, <span class="built_in">int</span> msg, IntPtr wParam, IntPtr lParam, <span class="keyword">ref</span> <span class="built_in">bool</span> handled</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当收到 WM_HOTKEY 消息并且热键 ID 匹配时，会调用 hotKeyCallBackHanlder()，即执行了预先设置的回调函数。</span></span><br><span class="line">    <span class="keyword">if</span> (msg == WM_HOTKEY &amp;&amp; wParam.ToInt32() == HOTKEY_ID)</span><br><span class="line">    &#123;</span><br><span class="line">        hotKeyCallBackHanlder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IntPtr.Zero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="更改热键"><a href="#更改热键" class="headerlink" title="更改热键"></a>更改热键</h2><p>在<code>User32API.cs</code>中创建一个新的方法<code>ModifyGlobalHotKey</code>。当用户在设置窗口中录入热键并点击完成按钮后，程序会更新存储热键的变量值，并将更新后热键的值传递给<code>User32API.cs</code>。</p><p><code>ModifyGlobalHotKey</code>会先注销先前的热键，然后尝试注册新的热键，如果注册失败则弹窗报错。</p><details class="note success"><summary><p>更改热键 ModifyGlobalHotKey</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ModifyGlobalHotKey</span>(<span class="params">WindowInteropHelper windowInteropHelper, Key key, ModifierKeys modifiers</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注销先前的热键</span></span><br><span class="line">    UnregisterHotKey(windowInteropHelper.Handle, HOTKEY_ID);</span><br><span class="line">    <span class="comment">//尝试注册新的热键</span></span><br><span class="line">    <span class="keyword">if</span> (!RegisterHotKey(windowInteropHelper.Handle, HOTKEY_ID, modifiers, (<span class="built_in">uint</span>)KeyInterop.VirtualKeyFromKey(key)))</span><br><span class="line">        MessageBox.Show(<span class="string">&quot;Failed to register global hotkey!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="读取和保存热键"><a href="#读取和保存热键" class="headerlink" title="读取和保存热键"></a>读取和保存热键</h2><p>由于组成热键的Key与ModifierKeys都是枚举类型，而<code>./Properties/Settings.settings</code>并不支持存储枚举类型，所以保存时要使用<code>ToString()</code>先将它们转化为字符串类型。</p><details class="note success"><summary><p>保存热键代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Key hotKey;</span><br><span class="line"><span class="keyword">private</span> ModifierKeys hotKeyModifiers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CloseButton_Click</span>(<span class="params"><span class="built_in">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Properties.Settings.Default.HotKey = hotKey.ToString();</span><br><span class="line">    Properties.Settings.Default.Modifiers = hotKeyModifiers.ToString();</span><br><span class="line">    Properties.Settings.Default.Save();</span><br><span class="line">    <span class="comment">//Close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>在程序启动时再通过<code>Enum.Parse()</code>来将字符串转换为枚举类型。这里需要将相关代码放在窗口初始化的代码中，如果放在窗口加载的代码中这段代码好像不会被执行，很迷惑。</p><details class="note success"><summary><p>读取热键代码</p></summary><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Key hotKey;</span><br><span class="line"><span class="keyword">private</span> ModifierKeys hotKeyModifiers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitializeComponent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取热键并转换类型</span></span><br><span class="line">    hotKey = (Key)Enum.Parse(<span class="keyword">typeof</span>(Key), Properties.Settings.Default.HotKey);</span><br><span class="line">    hotKeyModifiers = (ModifierKeys)Enum.Parse(<span class="keyword">typeof</span>(ModifierKeys), Properties.Settings.Default.Modifiers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h1><p>WPF程序的本地化有多种实现方法，例如使用资源字典，使用NuGet包，使用<code>.resx</code>资源文件等，我用的是比较方便的<code>.resx</code>资源文件。</p><h2 id="创建资源文件"><a href="#创建资源文件" class="headerlink" title="创建资源文件"></a>创建资源文件</h2><ol><li>在VS的解决方案资源管理器中打开<code>./Properties/Resources.resx</code>，这里的结构类似于c#中的<code>Dictionary&lt;string, string&gt;</code>，名称相当于<code>Key</code>，值就是<code>Value</code>。</li><li>填写默认语言资源键值</li><li>将<code>访问修饰符</code>从<code>Internal</code>更改为<code>Public</code></li><li>添加一个新的资源文件，并命名为<code>Resources.[LCID].resx</code>，这里的<code>[LCID]</code>是Windows语言代码标识符，例如简体中文的资源文件应该被命名为<code>Resources.zh-CN.resx</code>，完整的语言代码标识符详见<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-lcid/a9eac961-e77d-41a6-90a5-ce1a8b0cdb9c?redirectedfrom=MSDN">MS-LCID</a><div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/qV8WgfKp1siz3he.png" alt="bpc_resx1.png"></div><div class="group-picture-column"><img data-src="https://s2.loli.net/2023/08/18/Ym1iJnjEg9TUR8x.png" alt="bpc_resx2.png"></div></div></div></li><li>将<code>Resources.resx</code>中的内容复制到新建的资源文件中，然后根据语言修改对应的值<br><img data-src="https://s2.loli.net/2023/08/18/xZBtpjzkPunINsb.png" alt="bpc_resx3.png"></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="XAML"><a href="#XAML" class="headerlink" title="XAML"></a>XAML</h3><p>在xaml文件中添加新的命名空间引用，将<code>PackageName</code>替换为你的项目名称</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:lang=<span class="string">&quot;clr-namespace:[PackageName].Properties&quot;</span></span><br></pre></td></tr></table></figure><p>在文本的内容中使用<code>x:Static</code>来引用资源，下面的示例中<code>KeyName</code>就是语言资源文件中的键值<code>Name</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text=<span class="string">&quot;&#123;x:Static lang:Resources.KeyName&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>代码中可以直接引用</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = Properties.Resources.KeyName;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>我实现的功能是程序启动时，根据当前系统的语言标识自动切换至对应的语言，目前仅支持简体中文与英文。在代码中可以使用<code>CultureInfo.CurrentUICulture.Name</code>来获取当前系统的语言标识。实现此功能需要修改<code>App.xaml.cs</code>，完整代码如下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnStartup(e);</span><br><span class="line">    <span class="keyword">if</span> (CultureInfo.CurrentUICulture.Name == <span class="string">&quot;zh-CN&quot;</span>)<span class="comment">//如果当前系统语言标识为`zh-CN`简体中文</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.CurrentThread.CurrentUICulture = <span class="keyword">new</span> CultureInfo(<span class="string">&quot;zh-CN&quot;</span>);<span class="comment">//将程序语言设置为简体中文，使用./Properties/Resources.zh-CN.resx</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则使用./Properties/Resources.resx中设置的默认语言</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h1><p>VS生成的解决方案文件夹中有很多文件，包括图片、音频等资源文件以及所需的DLL运行库，这些都是程序运行所需的文件，也被称为依赖项。如果尝试单独将其中的exe文件拷贝到其他的目录，它是无法运行的，因为缺少了依赖项。由此带来的问题是：用户需要下载包含依赖项的整个文件夹才能使用这个软件，这非常的不方便。所以这里需要解决的问题就是如何将所需要的文件全部打包到一个单一的exe中，让用户能够开箱即用。解决方案是安装两个NuGet包：<code>Costura.Fody</code>与<code>Resource.Embedder</code></p><h2 id="Costura-Fody"><a href="#Costura-Fody" class="headerlink" title="Costura.Fody"></a>Costura.Fody</h2><p><a target="_blank" rel="noopener" href="https://github.com/Fody/Costura">Costura.Fody</a> 是Fody的一个开源附加程序，它的主要功能是将程序集中的依赖项嵌入到主程序集中，以减少发布和部署时的外部依赖。它通过在编译时修改 IL（Intermediate Language）代码来实现这一点，因此我们无需担心在运行时缺少外部依赖的问题。</p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>在VS的NuGet管理器中搜索并找到Costura.Fody就能够安装。由于它是Fody的附加程序，在安装的时候会同时安装Fody与很多的依赖项，大概有40个（两眼一黑.jpg）</p><p>安装完成后，新建一个名为<code>FodyWeavers.xml</code>的文件，并添加到解决方案资源管理器的根目录中。然后将下面的内容粘贴到文件中并保存就可以了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Weavers</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;FodyWeavers.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Costura</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Weavers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时在VS中重新生成解决方案，可以看到生成的exe文件的体积比原来大了很多，将它单独拷贝到其他的目录也能够正常使用。</p><h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>我在为程序添加本地化支持的时候遇到了新的问题，新创建的<code>.resx</code>语言文件没有被Costura.Fody正确的添加到exe中，导致程序运行时始终只能显示英语。如果只是在VS中调试，程序是能够以新添加的语言显示的，但是将exe文件单独拷贝出来后，就变回了默认语言。</p><p>此时<code>./bin/Debug</code>目录中的文件结构为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./Debug</span><br><span class="line">    │  </span><br><span class="line">    ├──ProjectName.exe</span><br><span class="line">    │</span><br><span class="line">    └──./zh-CN</span><br><span class="line">            │</span><br><span class="line">            └──xxxxx.dll</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据查阅到的资料，我推断这是因为本地化相关的资源属于<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/core/extensions/create-satellite-assemblies">附属程序集</a>（Satellite Assembly），附属程序集的资源在特定区域中是可用的，只有当用户选择了相应的区域设置时，相关资源才会被加载。而当Costura.Fody运行时，因为新的语言文件并没有被选择并加载，所以只有默认的语言文件被嵌入，在打包完成后新的语言文件才会被加载到解决方案的目录中。</p><div class="note primary"><p>相关的问题在GitHub中已有讨论：<a target="_blank" rel="noopener" href="https://github.com/Fody/Costura/issues/61">Costura doesn’t embed resource satellite assemblies</a>，并且有人给出了解决方案：安装Resource.Embedder，与Costura.Fody搭配使用。</p></div><details class="note success"><summary><p>附属程序集</p></summary><h3 id="附属程序集"><a href="#附属程序集" class="headerlink" title="附属程序集"></a>附属程序集</h3><blockquote><p>以下是来自ChatGPT的说明</p></blockquote><p>在 WPF中，主程序集和附属程序集是两种不同的程序集概念，它们在应用程序的组织、部署和访问资源方面有一些不同之处。</p><h4 id="主程序集（Primary-Assembly）"><a href="#主程序集（Primary-Assembly）" class="headerlink" title="主程序集（Primary Assembly）"></a>主程序集（Primary Assembly）</h4><p>主程序集是应用程序的核心程序集，它通常包含应用程序的启动代码、主要逻辑和主窗口等。主程序集可以包含各种资源，如 XAML 文件、图像、样式、模板等。这些资源在应用程序的整个生命周期内都可以被访问和使用。主程序集一般具有以下特点：</p><ul><li>包含启动点： 主程序集包含应用程序的入口点，这是应用程序启动时执行的代码。</li><li>全局资源： 主程序集中的资源可以被整个应用程序访问，无需特定的引用。</li><li>常驻内存： 主程序集中的资源在应用程序运行期间一直保持在内存中，除非显式释放。</li></ul><h4 id="附属程序集（Satellite-Assembly）"><a href="#附属程序集（Satellite-Assembly）" class="headerlink" title="附属程序集（Satellite Assembly）"></a>附属程序集（Satellite Assembly）</h4><p>附属程序集是用于本地化和资源管理的辅助程序集。它们包含应用程序的本地化文本、图像和其他资源的翻译或本地化版本。附属程序集使应用程序能够根据用户的语言和地区选择正确的资源。附属程序集一般具有以下特点：</p><ul><li>本地化资源： 附属程序集包含本地化或不同语言版本的资源，用于适应不同的语言和地区。</li><li>随需加载： 附属程序集在需要时才会被加载到内存中，以减少内存占用。</li><li>命名规则： 附属程序集的命名通常基于语言和区域设置，如AssemblyName.resources.dll。</li><li>特定于区域： 附属程序集的资源在特定区域中是可用的，只有当用户选择了相应的区域设置时，相关资源才会被加载。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主程序集包含应用程序的主要逻辑和资源，附属程序集用于本地化和资源管理。主程序集包含应用程序的核心代码和全局资源，而附属程序集包含特定语言和地区的本地化资源。通过将资源分为主程序集和附属程序集，WPF 应用程序可以实现多语言支持、资源管理和更好的内存利用。</p></details><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用Costura.Fody重新生成解决方案后，VS中xaml文件的预览会报错，这是因为Costura.Fody将资源全部嵌入了exe文件，导致VS的设计环境无法根据原有的相对路径找到资源，从而产生预览报错。在设计与预览时将<code>FodyWeavers.xml</code>中的<code>&lt;Costura /&gt;</code>暂时注释掉就可以解决。</p><h2 id="Resource-Embedder"><a href="#Resource-Embedder" class="headerlink" title="Resource.Embedder"></a>Resource.Embedder</h2><p><a target="_blank" rel="noopener" href="https://www.nuget.org/packages/Resource.Embedder/">Resource.Embedder</a> 是一个用于将资源文件嵌入到 .NET 程序集中的工具。它的工作原理是通过创建一个虚拟的文件系统，将资源文件嵌入到其中，然后由 Costura.Fody 将这个虚拟文件系统嵌入到主程序集中，从而实现了附属程序集的嵌入。</p><p>安装方法同上，直接在VS的NuGet管理器中搜索并安装，安装完成后不需要进行任何的设置。此时在VS中重新生成解决方案，此时exe文件已经能够以新的语言显示并单独运行。</p><h1 id="Net-Framework"><a href="#Net-Framework" class="headerlink" title=".Net Framework"></a>.Net Framework</h1><p><code>.NET Framework</code> 是微软开发的一种用于在 Windows 操作系统上构建和运行应用程序的开发框架。程序使用了<code>.Net Framework 4.8</code> 作为目标框架。</p><p>Windows系统从 <code>Windows 10 May 2019 Update（版本号 1903）</code>后开始预装<code>.Net Framework 4.8</code>，所以如果在更早版本的Windows上运行此程序需要额外安装<code>.Net Framework 4.8</code></p><h2 id="NET-Framework-版本与-Windows-版本的关系"><a href="#NET-Framework-版本与-Windows-版本的关系" class="headerlink" title=".NET Framework 版本与 Windows 版本的关系"></a>.NET Framework 版本与 Windows 版本的关系</h2><ul><li>.NET Framework 1.0 和 1.1： 首次发布时与 Windows XP 兼容。</li><li>.NET Framework 2.0： 兼容 Windows XP、Windows Server 2003 和 Windows Vista。</li><li>.NET Framework 3.0 和 3.5： 内置于 Windows Vista 和 Windows Server 2008 中，也可以通过更新包安装在 Windows XP 和 Windows Server 2003 上。</li><li>.NET Framework 4.0： 兼容 Windows XP、Windows Server 2003、Windows Vista、Windows 7、Windows Server 2008 和 Windows Server 2008 R2。</li><li>.NET Framework 4.5 到 4.8： 兼容 Windows 7、Windows 8、Windows 8.1、Windows 10，以及相应的 Windows Server 版本。</li></ul><h2 id="Net-Core-与-Net-Framework"><a href="#Net-Core-与-Net-Framework" class="headerlink" title=".Net Core 与 .Net Framework"></a>.Net Core 与 .Net Framework</h2><p>.NET Core 和 .NET Framework 都是由 Microsoft 开发的跨平台开发框架，这里简单记录下.Net Core 与 .Net Framework的区别。</p><ol><li>跨平台支持<ul><li>.NET Core：设计初衷就是跨平台的，可以在 Windows、Linux 和 macOS 上运行。</li><li>.NET Framework 主要面向 Windows 平台，不能直接在其他操作系统上运行。</li></ul></li><li>开源性质<ul><li>.NET Core：是完全开源的，其源代码托管在 GitHub 上。</li><li>.NET Framework：虽然有一些开源的组件和工具，但整体不是完全开源的。</li></ul></li><li>依赖关系和部署<ul><li>.NET Core：采用 NuGet 管理依赖，应用程序可以自包含地部署所需的运行时库。</li><li>.NET Framework：应用程序依赖于 GAC（全局程序集缓存），开发人员需要确保目标计算机上存在所需的 .NET Framework 版本。</li></ul></li><li>版本和更新<ul><li>.NET Core：发布周期相对较短，更新频繁，每次更新都有新的功能和改进。</li><li>.NET Framework：发布周期较长，更新相对较慢，以 Service Pack 或更大的版本形式发布。</li></ul></li><li>API 支持<ul><li>.NET Core：提供了更现代和精简的 API 集，一些 Windows 特定的功能可能在 .NET Core 中不支持。</li><li>.NET Framework：提供了丰富的 Windows API 支持，可以访问广泛的 Windows 功能。</li></ul></li><li>WPF 和 WinForms<ul><li>.NET Core：目前不支持原生的 WPF 和 WinForms 应用程序开发，但可以通过一些工具和库实现。</li><li>.NET Framework：提供完整的 WPF 和 WinForms 支持。</li></ul></li><li>性能<ul><li>.NET Core：由于设计轻量，跨平台特性，通常比 .NET Framework 在性能方面更优。</li><li>.NET Framework：针对 Windows 平台进行了优化，但在跨平台和性能方面可能相对较弱。</li></ul></li></ol><p><strong>吐槽</strong>：怎么写文档比做UI还累。。。。。。</p></div><footer class="post-footer"><div><div style="text-align:center;color:#ccc;font-size:14px">---------- 我是有底线哒 <i class="fa fa-dice-d20"></i> 感谢您的阅读 ----------</div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Sirius</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://siriusq.top/BongoPawClicker.html" title="Bongo Paw Clicker 开发记录">https://siriusq.top/BongoPawClicker.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/WPF/" rel="tag"><i class="fa fa-tag"></i> WPF</a> <a href="/tags/Bongo-Paw-Clicker/" rel="tag"><i class="fa fa-tag"></i> Bongo Paw Clicker</a> <a href="/tags/Log/" rel="tag"><i class="fa fa-tag"></i> Log</a> <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C#</a></div><div class="post-nav"><div class="post-nav-item"><a href="/TurnOniGpu.html" rel="prev" title="同时启用独显与核显"><i class="fa fa-angle-left"></i> 同时启用独显与核显</a></div><div class="post-nav-item"><a href="/Stellaris-Mod.html" rel="next" title="群星 Mod 制作与上传日志">群星 Mod 制作与上传日志 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Sirius</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">182k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">11:02</span></span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("03/31/2019 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://unpkg.com/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.31/dist/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script><script src="https://unpkg.com/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script><script src="https://unpkg.com/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script src="https://unpkg.com/quicklink@2.3.0/dist/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://siriusq.top/BongoPawClicker.html"}</script><script src="/js/third-party/quicklink.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"Siriusq","repo":"gitalk-commnet","client_id":"4217cae26df745a55acd","client_secret":"b7f2cc0c82be38a4e0f294f12f761bc4799669cd","admin_user":"Siriusq","distraction_free_mode":false,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":null,"js":{"url":"https://unpkg.com/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"62f82345e6ebd989df564dbb69dd0ab8"}</script><script src="/js/third-party/comments/gitalk.js"></script><script type="text/javascript" src="/js/crash_cheat.js"></script><script async src="/js/fireworks.js"></script><script src="https://unpkg.com/@splidejs/splide@4.1.4/dist/js/splide.min.js"></script><script>window.splideStyles={arrowColor:"#fc8d5d",arrowHoverColor:"#fc6423",paginationColor:"#fc8d5d",paginationActiveColor:"#fc6423",paginationHoverColor:"#fc6423",borderRadius:"1px",borderColor:{light:"#eee",dark:"#444"},shadowColor:{light:"rgba(0, 0, 0, 0.1)",dark:"rgba(0, 0, 0, 0.3)"}},window.splideDarkMode="auto",window.mediumZoomEnabled=!1</script><script type="text/javascript">// 页面加载事件监听
document.addEventListener('DOMContentLoaded', function () {
    splideLoadingHandler();
    initGlobalMediumZoom();
});

document.addEventListener('pjax:success', function () {
    splideLoadingHandler();
    initGlobalMediumZoom();
});

// PJAX开启时销毁所有splide实例，不然开启自动播放时图片简介和图片对不上
document.addEventListener('pjax:send', () => {
    destroySplideInstances();
});

window.splideInstances = [];
function destroySplideInstances() {
    window.splideInstances.forEach((instance) => {
        instance.destroy(); // 销毁实例
    });
    window.splideInstances = []; // 清空数组
}

// Splid 加载处理
function splideLoadingHandler() {
    // 检查页面是否含有轮播图片
    const splideEl = document.querySelector('.splide');
    if (!splideEl) {
        return; // 如果不存在轮播，则不执行初始化
    }

    // 检查是否开启Next主题的动画
    const isMotionEnabled = typeof CONFIG !== 'undefined' && CONFIG && CONFIG.motion && CONFIG.motion.enable;
    if (isMotionEnabled) {
        // Motion 开启时延迟加载轮播组件，等待动画完成。把组件加入动画有bug，一直搞不定，只能曲线救国
        setTimeout(function () {
            // 初始化轮播组件
            initSplide();
        }, 500);  // 延迟 500ms，确保动画完成后再初始化
    } else {
        // Motion 关闭时立即初始化
        initSplide();
    }

    // 处理 fancybox，默认设置会切换焦点图片造成轮播组件混乱
    if (typeof Fancybox !== "undefined") {
        adjustFancybox();
    }

    // 初始化轮播组件中的 Medium Zoom
    if (mediumZoomEnabled) {
        initCarouselMediumZoom();
    }

    // 应用主题样式
    applySplideStyle();
}

// 初始化 Splide
function initSplide() {
    const splideElements = document.querySelectorAll('.splide');
    splideElements.forEach(splideEl => {
        const options = JSON.parse(splideEl.getAttribute('data-splide'));
        // 如果轮播组件中只有一张图片，则隐藏箭头
        const slideCount = splideEl.querySelectorAll('.splide__slide').length;
        if (slideCount <= 1) {
            options.arrows = false;
        }
        // 简介设置
        const splide = new Splide(splideEl, options);
        splide.on('mounted move', function () {
            const activeSlide = splide.Components.Slides.getAt(splide.index);
            const caption = activeSlide.slide.dataset.caption;
            const captionId = splideEl.getAttribute('data-caption-id');

            const captionElement = document.getElementById(captionId);
            if (captionElement) {
                captionElement.innerText = caption || '';  // 如果没有简介，设置为空字符串
            }
        });
        splide.mount();
        window.splideInstances.push(splide); // 将实例存储到数组中   
    });
}

// 应用主题明暗样式
function applySplideStyle() {
    const applyThemeStyles = (theme, splideStyles) => {
        const borderColor = theme === 'dark' ? splideStyles.borderColor.dark : splideStyles.borderColor.light;
        const shadowColor = theme === 'dark' ? splideStyles.shadowColor.dark : splideStyles.shadowColor.light;
        document.documentElement.style.setProperty('--carousel-border-color', borderColor);
        document.documentElement.style.setProperty('--carousel-shadow-color', shadowColor);
        document.documentElement.style.setProperty('--carousel-border-radius', splideStyles.borderRadius);
        document.documentElement.style.setProperty('--carousel-arrow-color', splideStyles.arrowColor);
        document.documentElement.style.setProperty('--carousel-arrow-hover-color', splideStyles.arrowHoverColor);
        document.documentElement.style.setProperty('--carousel-pagination-color', splideStyles.paginationColor);
        document.documentElement.style.setProperty('--carousel-pagination-active-color', splideStyles.paginationActiveColor);
        document.documentElement.style.setProperty('--carousel-pagination-hover-color', splideStyles.paginationHoverColor);
    };

    let theme = 'light';
    if (window.splideDarkMode === 'auto') {
        theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    } else if (window.splideDarkMode === 'true') {
        theme = 'dark';
    }
    applyThemeStyles(theme, window.splideStyles);

    if (window.splideDarkMode === 'auto') {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            applyThemeStyles(e.matches ? 'dark' : 'light', window.splideStyles);
        });
    }
}

// 初始化非轮播图片的 Medium Zoom
function initGlobalMediumZoom() {
    // 检查是否启用 medium-zoom
    if (!mediumZoomEnabled) {
        return;
    }
    const zoomOutsideCarousel = mediumZoom('img:not(.splide .zoomable)', {
        background: 'rgba(0, 0, 0, 0.8)',
        margin: 24
    });
}

// 初始化轮播组件中的 Medium Zoom
function initCarouselMediumZoom() {
    const zoomCarousel = mediumZoom('.zoomable', {
        background: 'rgba(0, 0, 0, 0.8)',
        margin: 24,
        onOpen: (zoom) => {
            const img = zoom.target; // 获取正在缩放的图片
            img.classList.add('zooming'); // 添加一个缩放时的 class
        },
        onClose: (zoom) => {
            const img = zoom.target; // 获取缩放的图片
            img.classList.remove('zooming'); // 移除缩放时的 class
        }
    });

    zoomCarousel.on('open', () => {
        // 隐藏箭头和分页按钮
        document.querySelectorAll('.splide__arrow, .splide__pagination').forEach(el => {
            el.style.display = 'none';
        });
    });

    zoomCarousel.on('close', () => {
        // 重新显示箭头和分页按钮
        document.querySelectorAll('.splide__arrow, .splide__pagination').forEach(el => {
            el.style.display = '';
        });
    });
}

// fancybox 兼容调整
function adjustFancybox() {
    Fancybox.bind("[data-fancybox]", {
        placeFocusBack: false,  // 禁止 Fancybox 关闭时滚动回页面的焦点位置
    });

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === "childList") {
                removeFancyboxFromClones();
            }
        });
    });

    // 观察整个文档的 DOM 变化
    observer.observe(document, { childList: true, subtree: true });
}

// 移除克隆 Slide 中的 Fancybox 链接
function removeFancyboxFromClones() {
    const cloneSlides = document.querySelectorAll('.splide__slide--clone');

    cloneSlides.forEach((slide) => {
        const fancyboxLink = slide.querySelector('a.fancybox');
        if (fancyboxLink) {
            const img = fancyboxLink.querySelector('img');
            if (img) {
                // 将 img 挪出 a 标签
                fancyboxLink.replaceWith(img);
            }
        }
    });
}</script></body></html>